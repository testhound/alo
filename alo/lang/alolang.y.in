/* -*- mode:C -*-
 * Generic ALO grammar and C code.
 * Chip-specific grammar and C code lives in separate files, combined
 * with this via a script.
 */


%{
/* C (and C++ in our case) #include's and declarations */

#include <stdio.h>
#include <stdlib.h>		/* free() in bison.simple */
#include <stdarg.h>		/* vfprintf() */
#include <limits.h>		/* PATH_MAX, UNIT_MAX */
#include <stack>
#include <iostream>
#include <sstream>

#include <Alo.h>
#include <AloException.h>
using namespace Alo;
#include <OctaveInstructions.h>
#include <OctaveNode.h>
using namespace Llir;

#include "yystypes.h"
#include "aloutil.h"
#include "conditionals.h"
#include "defmacro.h"
#include "lexer.h"

void yyerror(const char *msg);
void fatal_error(const char *msg);
extern int yylex();

/* A few things have to be global... */
namespace Alo
{
  shared_ptr<LlirFile> g_currentFile;
  shared_ptr<LlirOctaveBlock> g_rootBlock;
  shared_ptr<LlirOctaveBlock> g_currentBlock;
  shared_ptr<AllocMemoryDirective> g_currentByteDirective;
  shared_ptr<AllocMemoryDirective> g_currentWordDirective;
  shared_ptr<AllocMemoryDirective> g_currentHalfWordDirective;
  shared_ptr<OctaveFactory> llirFactory;
  OctaveAlo *parseAlo;
}


/* Expression functions. */
static ExpContainer *add_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *subtract_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *multiply_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *divide_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *modulo_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *or_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *and_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *xor_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *leftshift_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *rightshift_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *oror_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *andand_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *leq_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *geq_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *lt_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *gt_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *eq_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *neq_op(ExpContainer *lhs, ExpContainer *rhs);
static ExpContainer *parens_eval(ExpContainer *e);
static ExpContainer *negate_op(ExpContainer *ec);
static ExpContainer *ones_complement_op(ExpContainer *ec);
static ExpContainer *assert_op(ExpContainer *tested_ex, ExpContainer *returned_ex);
static ExpContainer *unsigned_immed_container(unsigned int value);
static ExpContainer *label_container(const char *st);
static shared_ptr<const UnsignedImmediate> container_to_uimm_ptr(ExpContainer *e);
static shared_ptr<const SignedImmediate> container_to_simm_ptr(ExpContainer *e);
static shared_ptr<const LlirOperand> container_check_branch_expr(ExpContainer *e);
static CondBranchFlagsContainer *current_cond_branch_flags = NULL;
static TrafficSchedFlagsContainer *current_traffic_sched_flags = NULL;
static BrslArgsContainer *current_brsl_arg_set = NULL;

/* Type and mapping support. */
static stack<shared_ptr<Struct> >  structure_stack;
static shared_ptr<Struct> last_structure_popped;
static shared_ptr<Element> current_element;
static shared_ptr<Field> current_field;
static shared_ptr<BitField> current_bitfield;
static void structure_add_type(shared_ptr<Struct> s, shared_ptr<Type> t);
static void element_add_type(shared_ptr<Element> e, shared_ptr<Type> t);
static void do_mapping(TypeContainer *tc, const char *mapname, shared_ptr<const Register> reg);
static void undo_mapping(const char *name_or_path);
static void create_block(const char *block_name); 
static void create_block(); 

static void create_macro_block(); 
static void end_block(); 
static void end_block(const char *name); 
static void end_macro_block();
static int bit_position(int value);
static void assert_directive_check(ExpContainer *ec, const char *msg);
static void add_label_symbol(const char *label_name, OctaveSymbol::ScopeQualifier q);
static RegContainer *combine_single_regs_into_multi_reg(RegContainer *r1, RegContainer *r2);
static shared_ptr<const Register> combine_single_regs_into_multi_reg(shared_ptr<const Register> r1, shared_ptr<const Register> r2);
static RegContainer *clone_reg_as_single_with_offset(RegContainer *r, int offset);


/* Some action code moved into functions. */
BitopArgsContainer *handle_depb_form_RBRBN(RegContainer *r1, 
					   ExpContainer *r1_bitpos,
					   RegContainer *r2, 
					   ExpContainer *r2_bitpos,
					   ExpContainer *numbits);

BitopArgsContainer *handle_extb_form_RBRBN(RegContainer *r1, 
					   ExpContainer *r1_bitpos,
					   RegContainer *r2, 
					   ExpContainer *r2_bitpos,
					   ExpContainer *numbits);

BitopArgsContainer *handle_depb_form_FRBN(RegContainer *field1,
					  RegContainer *r2, 
					  ExpContainer *r2_bitpos,
					  ExpContainer *numbits);

BitopArgsContainer *handle_depb_form_RBFN(RegContainer *r1, 
					  ExpContainer *r1_bitpos,
					  RegContainer *field2,
					  ExpContainer *numbits);

BitopArgsContainer *handle_extb_form_RBFN(RegContainer *r1, 
					  ExpContainer *r1_bitpos,
					  RegContainer *field2,
					  ExpContainer *numbits);

BitopArgsContainer *handle_extb_form_FRBN(RegContainer *field1,
					  RegContainer *r2, 
					  ExpContainer *r2_bitpos,
					  ExpContainer *numbits);

BitopArgsContainer *handle_depb_form_RBF(RegContainer *r1, 
					 ExpContainer *r1_bitpos,
					 RegContainer *field2);

BitopArgsContainer *handle_depb_form_FRB(RegContainer *field1,
					 RegContainer *r2, 
					 ExpContainer *r2_bitpos);

BitopArgsContainer *handle_extb_form_FRB(RegContainer *field1,
					 RegContainer *r2, 
					 ExpContainer *r2_bitpos);

BitopArgsContainer *handle_depb_form_FF(RegContainer *field1,
					RegContainer *field2);

BitopArgsContainer *handle_extb_form_FF(RegContainer *field1,
					RegContainer *field2);
 
DepbiArgsContainer *handle_depbi_form1(ExpContainer *immed, 
				       RegContainer *r, 
				       ExpContainer *bitpos, 
				       ExpContainer *numbits);

DepbiArgsContainer *handle_depbi_form2(ExpContainer *immed, 
				       RegContainer *r);

TestArgsContainer *handle_test_form1(RegContainer *r, 
				     ExpContainer *bitnum);

TestArgsContainer *handle_test_form2(RegContainer *r);


/* Misc. stuff */
static unsigned long get_bitfield_size(shared_ptr<const BitField> bf);
static void source_file_completion();

/* Debug output. */
void d_printf(const char *fmt, ...);

/* We have to keep track of \'s that appear outside the context of
 * macro bodies.  They are semantically treated as newlines by the
 * parser, but they still need to go into the .i2 file to act as line
 * separators for the backend assembler.  */
static int macro_line_delimiter_seen = 0;

%}
/* 
   Bison declarations.  
   Tokens, 
   non-terminal symbols, 
   precedence, etc. 
*/

/* TOKENS */
%token <ul_value> DOT_TOKEN
%token <ul_value> MAP_TOKEN
%token <ul_value> IGNORED_TOKEN
%token <ul_value> IF_TOKEN
%token <ul_value> ELSEIF_TOKEN
%token <ul_value> ELSE_TOKEN
%token <ul_value> ENDIF_TOKEN
%token <ul_value> REGISTER_TOKEN
%token <ul_value> UNMAP_TOKEN
%token <ul_value> SECTION_TOKEN
%token <ul_value> BLOCK_TOKEN
%token <ul_value> ENDBLOCK_TOKEN
%token <ul_value> TEXT_TOKEN
%token <ul_value> DATA_TOKEN
%token <ul_value> LIST_TOKEN
%token <ul_value> NOLIST_TOKEN
%token <ul_value> LCOMM_TOKEN
%token <ul_value> COMMA_TOKEN
%token <ul_value> CONSTANT_TOKEN
%token <ul_value> COMM_TOKEN
%token <ul_value> ASCII_TOKEN
%token <ul_value> BYTE_TOKEN
%token <ul_value> HALFWORD_TOKEN
%token <ul_value> WORD_TOKEN
%token <ul_value> ALIGN_TOKEN
%token <ul_value> REF_TOKEN
%token <ul_value> STABS_TOKEN
%token <ul_value> STABN_TOKEN
%token <ul_value> STABD_TOKEN
%token <ul_value> MACRO_TOKEN
%token <ul_value> MACRO_LINE_DELIMITER_TOKEN
%token <ul_value> ENDMACRO_TOKEN
%token <ul_value> DEFMACRO_TOKEN
%token <ul_value> ENDDEF_TOKEN
%token <ul_value> ORG_TOKEN
%token <ul_value> CODE_TOKEN
%token <ul_value> STRUCTURE_TOKEN
%token <ul_value> ENDSTRUCTURE_TOKEN
%token <ul_value> ELEMENT_TOKEN
%token <ul_value> SIZEOF_TOKEN
%token <ul_value> OFFSETOF_TOKEN
%token <ul_value> ASSERT_DIRECTIVE_TOKEN
%token <ul_value> ASSERT_TOKEN
%token <ul_value> INVALID_DIRECTIVE_TOKEN
%token <ul_value> LSBOF_TOKEN
%token <ul_value> MSBOF_TOKEN
%token <ul_value> BITPOS_TOKEN
%token <ul_value> NRBITS_TOKEN
%token <ul_value> BASEOF_TOKEN
%token <ul_value> REGOF_TOKEN
%token <ul_value> REGNUM_TOKEN
%token <ul_value> MEETS_TOKEN
%token <ul_value> WARNING_TOKEN
%token <ul_value> ERROR_TOKEN
%token <ul_value> SREGISTER_TOKEN
%token <ul_value> SMAP_TOKEN
%token <ul_value> POS_TOKEN
%token <ul_value> ADD_TOKEN
%token <ul_value> ADDC_TOKEN
%token <ul_value> ADD4X_TOKEN
%token <ul_value> ADDNE_TOKEN
%token <ul_value> AND_TOKEN
%token <ul_value> MAX_TOKEN
%token <ul_value> MIN_TOKEN
%token <ul_value> OR_TOKEN
%token <ul_value> SUB_TOKEN
%token <ul_value> SUBB_TOKEN
%token <ul_value> XOR_TOKEN
%token <ul_value> SETB_TOKEN
%token <ul_value> SETBI_TOKEN
%token <ul_value> CLRB_TOKEN
%token <ul_value> CLRBI_TOKEN
%token <ul_value> RAND_TOKEN
%token <ul_value> ADDI_TOKEN
%token <ul_value> ADDCI_TOKEN
%token <ul_value> ADDNEI_TOKEN
%token <ul_value> SUBI_TOKEN
%token <ul_value> SUBBI_TOKEN
%token <ul_value> RANDI_TOKEN
%token <ul_value> ADDL_TOKEN
%token <ul_value> ADDWH_TOKEN
%token <ul_value> ADDWL_TOKEN
%token <ul_value> ADDWW_TOKEN
%token <ul_value> SUBL_TOKEN
%token <ul_value> SUBWH_TOKEN
%token <ul_value> SUBWL_TOKEN
%token <ul_value> SUBWW_TOKEN
%token <ul_value> ADDLI_TOKEN
%token <ul_value> ADDWHI_TOKEN
%token <ul_value> ADDWLI_TOKEN
%token <ul_value> ADDWWI_TOKEN
%token <ul_value> SUBLI_TOKEN
%token <ul_value> SUBWHI_TOKEN
%token <ul_value> SUBWLI_TOKEN
%token <ul_value> SUBWWI_TOKEN
%token <ul_value> BCDI_TOKEN
%token <ul_value> BCDR_TOKEN
%token <ul_value> BCI_TOKEN
%token <ul_value> BCR_TOKEN
%token <ul_value> BI_TOKEN
%token <ul_value> BR_TOKEN
%token <ul_value> BRS_TOKEN
%token <ul_value> BRSL_TOKEN
%token <ul_value> BRSPRE_TOKEN
%token <ul_value> BZR_TOKEN
%token <ul_value> BNZR_TOKEN
%token <ul_value> BZI_TOKEN
%token <ul_value> BNZI_TOKEN
%token <ul_value> BYTESW_TOKEN
%token <ul_value> CMOV_TOKEN
%token <ul_value> CMOVI_TOKEN
%token <ul_value> CMP_TOKEN
%token <ul_value> CMPI_TOKEN
%token <ul_value> CMPR_TOKEN
%token <ul_value> CMPRI_TOKEN
%token <ul_value> DEPB_TOKEN
%token <ul_value> DEPBI_TOKEN
%token <ul_value> DMASR_TOKEN
%token <ul_value> DMAP_TOKEN
%token <ul_value> DMAU0_TOKEN
%token <ul_value> DMAU1_TOKEN
%token <ul_value> EXTB_TOKEN
%token <ul_value> GET_TOKEN
%token <ul_value> HEC5_TOKEN
%token <ul_value> LSP_TOKEN
%token <ul_value> LINK_TOKEN
%token <ul_value> LINKS_TOKEN
%token <ul_value> LMM_TOKEN
%token <ul_value> LMMS_TOKEN
%token <ul_value> ANDI_TOKEN
%token <ul_value> ORI_TOKEN
%token <ul_value> XORI_TOKEN
%token <ul_value> FLS_TOKEN
%token <ul_value> FFS_TOKEN
%token <ul_value> PAR_TOKEN
%token <ul_value> LIL_TOKEN
%token <ul_value> LIH_TOKEN
%token <ul_value> LAIL_TOKEN
%token <ul_value> LAIH_TOKEN
%token <ul_value> LWIL_TOKEN
%token <ul_value> LWIH_TOKEN
%token <ul_value> MAXI_TOKEN
%token <ul_value> MINI_TOKEN
%token <ul_value> MAXPI_TOKEN
%token <ul_value> MV_TOKEN
%token <ul_value> MVRH_TOKEN
%token <ul_value> MVHR_TOKEN
%token <ul_value> MULH_TOKEN
%token <ul_value> MUL_TOKEN
%token <ul_value> MULHI_TOKEN
%token <ul_value> MULI_TOKEN
%token <ul_value> NOP_TOKEN
%token <ul_value> POL_TOKEN
%token <ul_value> POLC_TOKEN
%token <ul_value> RINT_TOKEN
%token <ul_value> RNMI_TOKEN
%token <ul_value> SHRAI_TOKEN
%token <ul_value> ROTLI_TOKEN
%token <ul_value> ROTRI_TOKEN
%token <ul_value> SHRI_TOKEN
%token <ul_value> SHLI_TOKEN
%token <ul_value> SHFT_TOKEN
%token <ul_value> SHFTA_TOKEN
%token <ul_value> SHRA_TOKEN
%token <ul_value> ROTL_TOKEN
%token <ul_value> ROTR_TOKEN
%token <ul_value> SHR_TOKEN
%token <ul_value> SHL_TOKEN
%token <ul_value> SMM_TOKEN
%token <ul_value> SMMS_TOKEN
%token <ul_value> SSP_TOKEN
%token <ul_value> TSETB_TOKEN
%token <ul_value> TCLRB_TOKEN
%token <ul_value> UNLINK_TOKEN
%token <ul_value> NOT_TOKEN
%token <ul_value> ZB_TOKEN
%token <ul_value> Z_BIT_TOKEN
%token <ul_value> SIGN_BIT_TOKEN
%token <ul_value> HC_TOKEN
%token <ul_value> C0_TOKEN
%token <ul_value> C1_TOKEN
%token <ul_value> C2_TOKEN
%token <ul_value> C3_TOKEN
%token <ul_value> C4_TOKEN
%token <ul_value> C5_TOKEN
%token <ul_value> C6_TOKEN
%token <ul_value> C7_TOKEN
%token <ul_value> C8_TOKEN
%token <ul_value> C9_TOKEN
%token <ul_value> C10_TOKEN
%token <ul_value> C11_TOKEN
%token <ul_value> C12_TOKEN
%token <ul_value> C13_TOKEN
%token <ul_value> C14_TOKEN
%token <ul_value> C15_TOKEN
%token <ul_value> CD_TOKEN
%token <ul_value> C_BIT_TOKEN
%token <ul_value> BF_TOKEN
%token <ul_value> UL_TOKEN
%token <ul_value> FL_TOKEN
%token <ul_value> PR_TOKEN
%token <ul_value> DLNK_TOKEN
%token <ul_value> DI_TOKEN
%token <ul_value> SX_TOKEN
%token <ul_value> BASE2_TOKEN
%token <ul_value> BASE3_TOKEN
%token <ul_value> MOD2_TOKEN
%token <ul_value> MOD4_TOKEN
%token <ul_value> MOD8_TOKEN
%token <ul_value> MOD16_TOKEN
%token <ul_value> MOD32_TOKEN
%token <ul_value> MOD64_TOKEN
%token <ul_value> MOD128_TOKEN
%token <ul_value> MOD256_TOKEN
%token <ul_value> MOD512_TOKEN
%token <ul_value> MOD1K_TOKEN
%token <ul_value> MOD2K_TOKEN
%token <ul_value> MOD4K_TOKEN
%token <ul_value> MOD8K_TOKEN
%token <ul_value> MOD16K_TOKEN
%token <ul_value> MOD32K_TOKEN
%token <ul_value> MOD64K_TOKEN
%token <ul_value> MOD128K_TOKEN
%token <ul_value> MOD256K_TOKEN
%token <ul_value> MOD512K_TOKEN
%token <ul_value> MOD1M_TOKEN
%token <ul_value> MOD2M_TOKEN
%token <ul_value> MOD4M_TOKEN
%token <ul_value> MOD8M_TOKEN
%token <ul_value> MOD16M_TOKEN
%token <ul_value> MOD32M_TOKEN
%token <ul_value> MOD64M_TOKEN
%token <ul_value> MOD128M_TOKEN
%token <ul_value> MOD256M_TOKEN
%token <ul_value> MOD512M_TOKEN
%token <ul_value> MOD1G_TOKEN
%token <ul_value> MOD2G_TOKEN
%token <ul_value> ESS0_TOKEN
%token <ul_value> ESS1_TOKEN
%token <ul_value> ESS2_TOKEN
%token <ul_value> ESS3_TOKEN
%token <ul_value> ESS4_TOKEN
%token <ul_value> ESS5_TOKEN
%token <ul_value> ESS6_TOKEN
%token <ul_value> ESS7_TOKEN
%token <ul_value> ESS8_TOKEN
%token <ul_value> ESS9_TOKEN
%token <ul_value> ESS10_TOKEN
%token <ul_value> ESS11_TOKEN
%token <ul_value> ESS12_TOKEN
%token <ul_value> ESS13_TOKEN
%token <ul_value> ESS14_TOKEN
%token <ul_value> ESS15_TOKEN
%token <ul_value> ESS16_TOKEN
%token <ul_value> ESS17_TOKEN
%token <ul_value> ESS18_TOKEN
%token <ul_value> ESS19_TOKEN
%token <ul_value> ESS20_TOKEN
%token <ul_value> ESS21_TOKEN
%token <ul_value> ESS22_TOKEN
%token <ul_value> ESS23_TOKEN
%token <ul_value> ESS24_TOKEN
%token <ul_value> ESS25_TOKEN
%token <ul_value> ESS26_TOKEN
%token <ul_value> ESS27_TOKEN
%token <ul_value> ESS28_TOKEN
%token <ul_value> ESS29_TOKEN
%token <ul_value> ESS30_TOKEN
%token <ul_value> ESS31_TOKEN
%token <ul_value> BGEZ_TOKEN
%token <ul_value> BNC_TOKEN
%token <ul_value> BZ_TOKEN
%token <ul_value> BLEZ_TOKEN
%token <ul_value> BLZ_TOKEN
%token <ul_value> BNZ_TOKEN
%token <ul_value> BNO_TOKEN
%token <ul_value> BAGB_TOKEN
%token <ul_value> BAGEB_TOKEN
%token <ul_value> BAEB_TOKEN
%token <ul_value> BALEB_TOKEN
%token <ul_value> BALB_TOKEN
%token <ul_value> BANEB_TOKEN
%token <ul_value> LNK1_TOKEN
%token <ul_value> LNK2_TOKEN
%token <ul_value> LNK3_TOKEN
%token <ul_value> DELETE_TOKEN
%token <ul_value> FP_TOKEN
%token <ul_value> FPB_TOKEN
%token <ul_value> NB_TOKEN
%token <ul_value> CSB_TOKEN
%token <ul_value> GPA_TOKEN
%token <ul_value> GPU_TOKEN
%token <ul_value> GPB_TOKEN
%token <ul_value> GR_TOKEN
%token <ul_value> GU_TOKEN
%token <ul_value> GW_TOKEN
%token <ul_value> GZ_TOKEN
%token <ul_value> NC_TOKEN
%token <ul_value> NT_TOKEN
%token <ul_value> RB_TOKEN
%token <ul_value> FB_TOKEN
%token <ul_value> S_TOKEN
%token <ul_value> RSCH_TOKEN
%token <ul_value> I_TOKEN
%token <ul_value> FR_TOKEN
%token <ul_value> CLOSE_TOKEN
%token <ul_value> NE_TOKEN
%token <ul_value> R_TOKEN
%token <ul_value> A_TOKEN
%token <ul_value> T_TOKEN
%token <ul_value> OAM_TOKEN
%token <ul_value> RP_TOKEN
%token <ul_value> LOG_TOKEN
%token <ul_value> NG2_TOKEN
%token <ul_value> GC1A_TOKEN
%token <ul_value> GC1O_TOKEN
%token <ul_value> GC1B_TOKEN
%token <ul_value> GC2A_TOKEN
%token <ul_value> GC2O_TOKEN
%token <ul_value> GC2B_TOKEN
%token <ul_value> NUL_TOKEN
%token <ul_value> GTA_TOKEN
%token <ul_value> GTO_TOKEN
%token <ul_value> GTB_TOKEN
%token <ul_value> GSTICK_TOKEN
%token <ul_value> LO17_RELOC_TOKEN
%token <ul_value> LO16_RELOC_TOKEN
%token <ul_value> HI16_RELOC_TOKEN
%token <ul_value> WORD_ALIGN_TOKEN
%token <ul_value> NEWLINE_TOKEN
%token <ul_value> HALFWORD_ALIGN_TOKEN
%token <ul_value> BYTE_ALIGN_TOKEN
%token <text>     IDENTIFIER_TOKEN
%token <text>     STRUCTURE_REFERENCE_TOKEN
%token <text>     QUOTED_STRING_TOKEN


%type <reg> alt_reg_spec
%type <reg> single_reg_spec
%type <reg> reg_spec
%type <reg> sizeof_reg_spec
%type <reg> scratchpad_reg_spec
%type <reg> bitop_reg_spec
%type <reg> hardreg
%type <reg> mapname_or_symreg
%type <reg> mappath
%type <reg> sregister_multireg
%type <reg> baseof
%type <reg> regof
%type <reg> unlink_form

%type <opt_reg> optional_reg

%type <multireg_args> multireg_form
%type <multireg_args> multireg_addr
%type <multireg_args> scratchpad_form
%type <multireg_args> scratchpad_addr

%type <opt_mod_abc> optional_mod_abc
%type <opt_abc>     optional_abc_flag
%type <opt_abc_zb>  optional_abc_zb
%type <opt_depb>    optional_depb_flag
%type <opt_sign>    optional_sign_flag
%type <opt_cycs>             optional_cycs_flag
%type <opt_branch_disp> optional_branch_disp
%type <opt_branch_disp_abc> optional_branch_disp_with_abc
%type <opt_abc_compare_sign> optional_abc_compare_sign
%type <opt_mod_abc_compare> optional_mod_abc_compare

%type <opt_hec> optional_hec_flag
%type <opt_sx> optional_sx_flag
%type <opt_di> optional_di_flag
%type <opt_lnk> optional_lnk_flag
%type <ess> ess
%type <of_ess> ess_flag

%type <insn> processor_instruction
%type <insn> generic_processor_instruction
%type <ul_value> sizeof
%type <ul_value> assert_rule
%type <ul_value> offsetof
%type <ul_value> regnum
%type <ul_value> base_reg
%type <ul_value> lsbof
%type <ul_value> msbof
%type <ul_value> bitpos
%type <ul_value> nrbits
%type <ul_value> position
%type <text> dot_expr
%type <ul_value> align_val
%type <ul_value> abc_flag
%type <ul_value> cycs_flag
%type <ul_value> abc_compare_flag
%type <ul_value> mod_flag
%type <ul_value> relative_offsetof

%type <text> type_or_map_string
%type <text> label_name


%type <l_value> org_fill_value
%type <bitop_args> depb_form
%type <bitop_args> extb_form
%type <depbi_args> depbi_form
%type <test_args> test_form

%type <ex> expr
%type <ex> constant_expression
%type <ex> expression
%type <ex> imm3
%type <ex> sft_imm5
%type <ex> imm6
%type <ex> lmm_imm8
%type <ex> lmm_imm14
%type <ex> imm9
%type <ex> imm10
%type <ex> limd_imm16
%type <ex> limd_imm17
%type <ex> bitop_bitpos
%type <ex> bitop_small_int
%type <ex> bytesel0
%type <ex> bytesel1
%type <ex> bytesel2
%type <ex> bytesel3
%type <ex> bitop_numbits
%type <ex> param_offset
%type <ex> pos_offset
%type <ex> pipe_depth

%type <pipedepth> optional_pipe_depth

%type <cbflags> cond_branch_args
%type <tssflags> traffic_sched_flags
%type <bi_args> bi_arg_set
%type <brsl_args> brsl_arg_set

%type <parse_construct> statement
%type <parse_construct> assembler_directive
%type <parse_construct> generic_assembler_directive 
%type <parse_construct> newline
%type <parse_construct> instruction
%type <parse_construct> structure_definition
%type <parse_construct> ends_directive
%type <parse_construct> element_directive
%type <parse_construct> struct_content
%type <parse_construct> struct_contents
%type <dot_struct> structure_directive
%type <type> type_or_typepath_or_mapping_or_mappath


/* Expression operator precedence is in the same order as C. */
%left OROR_TOKEN
%left ANDAND_TOKEN
%left '|'
%left '^'
%left  '&'
%left EQ_TOKEN NEQ_TOKEN
%left '<' '>' LEQ_TOKEN GEQ_TOKEN
%left LEFT_SHIFT_TOKEN RIGHT_SHIFT_TOKEN
%left  '+' '-'
%left  '*' '/' '%'
%nonassoc ONES_COMPLEMENT
%nonassoc UMINUS



%%
/* Grammar rules.   */

/* Top-level productions: */
source_file: statement_list 
             {  
	       source_file_completion();
             }
             ;

statement_list : /* empty */
               | statement_list ignored_text {  }
               | statement_list statement { 
                     if (macro_line_delimiter_seen)
		       {
			 /* FIXME: create new node... */
			 g_currentBlock->addLlirNode(g_currentBlock, 
						     llirFactory->createNewLineNode(get_node_line(), 
										    get_src_line(),
										    get_src_file(),
										    "\\"));
			 macro_line_delimiter_seen = 0;
		       }
                     aloutil_cleanup(); 
                  }
               ;
statement : assembler_directive 
            { }
          | newline 
            { }
          | label 
            { }
          | instruction 
            { }
          | DOT_TOKEN error newline
            { /* This handles the case where a non-existed or misspelled
		 directive was supplied, for example ".stract".
		 Just having the error production here should generate
		 a parse error.  Without it, we were getting segfaults. */ 
	    }
          ;

/*
 * When conditional directives evaluate "false", the lexer just
 * returns IGNORED_TOKEN until another conditional directive is
 * encountered. 
 */
ignored_text : IGNORED_TOKEN {  }
             ;

ignored_defmacro_body : /* empty */
                      | ignored_defmacro_body IGNORED_TOKEN {  }
                      ;

/* Types, mappings, label symbols, register symbols: */

/* Earlier assemblers could only map to types or type paths. */
type_or_typepath_or_mapping_or_mappath: IDENTIFIER_TOKEN 
           { 
	     NEW(TypeContainer, tc);
	     tc->ty = lookupTypePath($1);
	     tc->name = $1;
	     $$ = tc;
           }
         | STRUCTURE_REFERENCE_TOKEN 
           { 
	     NEW(TypeContainer, tc);
	     tc->ty = lookupTypePath($1);
	     tc->name = $1;
	     $$ = tc;
	   }
         ;
mapname_or_symreg: IDENTIFIER_TOKEN 
           { 
	     /* Return a multireg if a mapname.  Return a singlereg if a symreg. */
	     NEW(RegContainer, rc);
	     rc->regPtr = lookupMapNameOrSymReg($1);
	     $$ = rc;
           }
                ;

hardreg: REGISTER_TOKEN 
         { 
	   NEW(RegContainer, rc); 
	   rc->regPtr = llirFactory->createHardReg($1); 
	   $$ = rc; 
         }
       ;

mappath:  STRUCTURE_REFERENCE_TOKEN 
          { 
	    NEW(RegContainer, rc);
	    shared_ptr<const Type> ty;
	    rc->regPtr = lookupMapReferencePath($1);
	    ty = lookupType($1);
	    shared_ptr<const BitField> bitfield;
	    /* This is the only chance that a reg_spec might be a bitfield. */
	    if (bitfield = shared_dynamic_cast<const BitField>(ty))
	      {    
		rc->isfield = 1;
		rc->bitfield = bitfield;
	      }
	    
	    /* check whether map path got resolved to a structure */
	    if (!isNullReg(rc->regPtr))
	      {
		rc->baseregPtr = getBaseOf($1);
		rc->baseregSet = 1;
	      }
	    else
	      {
		/* this is invalid input which does not allow further
		   processing of input, so throw and stop assembly */		   
		string s = string("found invalid map path ") + string(" : ") + string($1);
		throw IllegalRegisterOperand(s.c_str(),
					     get_src_line(),
					     get_src_file(), 
					     __LINE__, __FILE__);
	      }

	    $$ = rc;
	  }
        ;

sregister_multireg: single_reg_spec '-' single_reg_spec 
                    {
		      /* FIXME: Mark this syntax as deprecated?  It was never used in old code... */
		      NEW(RegContainer, mr);  
		      mr->regPtr =  combine_single_regs_into_multi_reg($1, $3)->regPtr;
		      $$ = mr;
		    }
                  ;

single_reg_spec: reg_spec { 
    shared_ptr<const SingleRegister> sr;
    shared_ptr<const MultiRegister> mr;
    /* Verify that reg_spec is only a single register. */
    if ((sr = shared_dynamic_cast<const SingleRegister>($1->regPtr)))
      {
	if ($1->isfield && (get_bitfield_size($1->bitfield) < 32))
	  {
	    /* Don't allow bitfields < 32 bits. */
	    parseAlo->logException(shared_ptr<IllegalRegisterOperand>(new IllegalRegisterOperand("argument must be a single-register or 32-bit bitfield",
												 get_src_line(),
												 get_src_file(),
												 __LINE__, __FILE__)));
	  }

	/* Let the parse continue whether or not there was an error. */
	$$ = $1;
      }

    else if ((mr = shared_dynamic_cast<const MultiRegister>($1->regPtr))) 
      {	
	/* Matt says they don't want a  multiregister argument (i.e. substructure)
	 * to stand in for a singlereg argument,  even if it spans only one reg. */
	parseAlo->logException(shared_ptr<IllegalRegisterOperand>(new IllegalRegisterOperand("cannot use mult-register expression for single-register argument",
											     get_src_line(), 
											     get_src_file(), 
											     __LINE__, __FILE__)));
	$$ = $1;
      }
  }
  ;

reg_spec: hardreg { $$ = $1; }
  | mappath { $$ = $1; }
  | mapname_or_symreg { $$ = $1; }
  | '(' reg_spec ')' { $$ = $2; }
  | reg_spec '[' expression ']' 
    { /* FIXME: NOTE - got rid of ()'s here, will it still work??? */
      $$ = clone_reg_as_single_with_offset($1, container_to_simm_ptr($3)->getValue());
    }
  | single_reg_spec ':' single_reg_spec 
    { 
      $$ = combine_single_regs_into_multi_reg($1, $3);
    }
  | baseof    { $$ = $1; }
  | regof     { $$ = $1; }
  ;


/*
 * alt_reg_spec is like reg_spec, but with mappath and hardreg removed,
 * because they need more context around them in the multireg_form rules.
 */
alt_reg_spec: mapname_or_symreg { $$ = $1; }
  | '(' reg_spec ')' { $$ = $2; }
  | reg_spec  '['  expression ']' {  
      $$ = clone_reg_as_single_with_offset($1, container_to_simm_ptr($3)->getValue());
    }
  | single_reg_spec ':' single_reg_spec {
      $$ = combine_single_regs_into_multi_reg($1, $3);
    }
  | baseof    { $$ = $1; }
  | regof     { $$ = $1; }
  ;

/*
 * sizeof() needs yet another special case reg spec.
 */
sizeof_reg_spec: hardreg { $$ = $1; }
  | IDENTIFIER_TOKEN 
    { 
      /* Explain this... */
      NEW(RegContainer, rc);
      rc->regPtr = llirFactory->createMultiHardReg(getSize($1)/4, 0); 
      $$ = rc;
    }
  | STRUCTURE_REFERENCE_TOKEN 
    {
      /* Explain this... */
      NEW(RegContainer, rc);
      rc->regPtr = llirFactory->createMultiHardReg(getSize($1)/4, 0); 
      $$ = rc;
    }
  | '(' sizeof_reg_spec ')' 
     { 
       $$ = $2; 
     }
  | sizeof_reg_spec  '['  expression ']' 
    {  
      $$ = clone_reg_as_single_with_offset($1, container_to_simm_ptr($3)->getValue());
    }
  | sizeof_reg_spec ':' sizeof_reg_spec 
    {
      $$ = combine_single_regs_into_multi_reg($1, $3);
    }
  | baseof    
    { 
      $$ = $1; 
    }
  | regof     
    { 
      $$ = $1; 
    }
  ;

/*
 * multireg_form does the following:
 *  a) uses alt_reg_spec to get the bulk of the register grammar
 *  b) calls out hardreg and mappath in separate rules
 *  c) includes "multireg_addr" at the end which gives Yacc more
 *     context to help resolve things.
 */
multireg_form: alt_reg_spec multireg_addr 
   {
     $2->regs = $1->regPtr;
     $$ = $2;
   }
   | mappath '-' mappath multireg_addr 
   { 
     $4->regs = combine_single_regs_into_multi_reg($1, $3)->regPtr;
     $$ = $4;
   }
   | hardreg '-' hardreg multireg_addr 
   {  
     $4->regs =  combine_single_regs_into_multi_reg($1, $3)->regPtr;
     $$ = $4;
   }
   | mappath '-' hardreg multireg_addr 
   {  
     $4->regs =  combine_single_regs_into_multi_reg($1, $3)->regPtr;
     $$ = $4;
   }
   | hardreg '-' mappath multireg_addr 
   {  
     $4->regs =  combine_single_regs_into_multi_reg($1, $3)->regPtr;
     $$ = $4;
   }
   | hardreg multireg_addr 
   { 
     $2->regs = $1->regPtr;
     $$ = $2;
   }
   | mappath multireg_addr 
   {
     $2->regs = $1->regPtr;
     $$ = $2;
   }
   ;

multireg_addr: single_reg_spec { 
               NEW(MultiRegArgsContainer, p);
	       shared_ptr<const UnsignedImmediate> zero(new UnsignedImmediate(0));
               p->mem = llirFactory->createRegPlusOffsetMemory($1->regPtr, zero);
	       $$ = p;	       
             }
             | lmm_imm8 '(' single_reg_spec ')' { 
               NEW(MultiRegArgsContainer, p);
	       p->mem = llirFactory->createRegPlusOffsetMemory($3->regPtr, $1->exprPtr);
	       $$ = p;	       
	     }
             | base_reg lmm_imm14  { 
               NEW(MultiRegArgsContainer, p);
	       if ($1 == 2)
		 p->mem = llirFactory->createBase2PlusOffsetMemory($2->exprPtr);
	       else
		 p->mem = llirFactory->createBase3PlusOffsetMemory($2->exprPtr);
	       $$ = p;	       
	     }
             ;

scratchpad_reg_spec:  hardreg { $$ = $1; }
  | mappath { $$ = $1; }
/*    | mapname_or_symreg { $$ = $1; } */
/*    | '(' single_reg_spec ')' { $$ = $2; } */
/*    | reg_spec '[' expression ']' {  */
/*        $$ = clone_reg_as_single_with_offset($1, container_to_simm_ptr($3)->getValue()); */
/*      } */
/*    | single_reg_spec ':' single_reg_spec {  */
/*        $$ = combine_single_regs_into_multi_reg($1, $3); */
/*      } */
  | baseof    { $$ = $1; }
  | regof     { $$ = $1; }
  ;

/*
 * scratchpad_form is similar to multireg_form, except for the scratchpad_addr forms...
 */
scratchpad_form: alt_reg_spec scratchpad_addr {
     $2->regs = $1->regPtr;
     $$ = $2;
   }
   | mappath '-' mappath scratchpad_addr { 
     $4->regs = combine_single_regs_into_multi_reg($1, $3)->regPtr;
     $$ = $4;
   }
   | hardreg '-' hardreg scratchpad_addr {  
     $4->regs =  combine_single_regs_into_multi_reg($1, $3)->regPtr;
     $$ = $4;
   }
   | hardreg scratchpad_addr { 
     $2->regs = $1->regPtr;
     $$ = $2;
   }
   | mappath scratchpad_addr {
     $2->regs = $1->regPtr;
     $$ = $2;
   }
   ;

scratchpad_addr: scratchpad_reg_spec { 
               NEW(MultiRegArgsContainer, p);
	       shared_ptr<const UnsignedImmediate> zero(new UnsignedImmediate(0));
               p->mem = llirFactory->createRegPlusOffsetMemory($1->regPtr, zero);
	       $$ = p;	       
             }
             | lmm_imm8 '(' single_reg_spec ')' { 
               NEW(MultiRegArgsContainer, p);
	       p->mem = llirFactory->createRegPlusOffsetMemory($3->regPtr, $1->exprPtr);
	       $$ = p;
	     }
             | lmm_imm14  {   
               NEW(MultiRegArgsContainer, p);
	       p->mem = llirFactory->createImpliedBase2OffsetMemory($1->exprPtr);
	       p->convert = 1;              /* base_reg is implied here, and must convert to LMM/SMM. */
	       $$ = p;	       
	     }
             ; 

/* 
 * unlink_form is a bit like multireg_form, just without the address part.  We can't
 * reuse this as part of multireg_form, because multireg_form needs the address
 * part for context to avoid certain ambiguities.
 */
unlink_form: reg_spec {
     $$ = $1;
   }
   | mappath '-' mappath  { 
     $$ = combine_single_regs_into_multi_reg($1, $3);
   }
   | hardreg '-' hardreg  {  
     $$ = combine_single_regs_into_multi_reg($1, $3);
   }
/*     | hardreg {  */
/*       $$ = $1; */
/*     } */
/*     | mappath { */
/*       $$ = $1; */
/*     } */
   ;

/*  reg_and_bitpos: single_reg_spec bitop_bitpos { $$ = handle_reg_and_bitpos_form1($1, $2); } */
/*                | reg_spec                     { $$ = handle_reg_and_bitpos_form2($1); } */

/* No ()'s in DEPB/EXTB registers. */
bitop_reg_spec:  hardreg { $$ = $1; }
  | mappath { $$ = $1; }
  | mapname_or_symreg { $$ = $1; }
  | '(' single_reg_spec ')' { $$ = $2; }
  | bitop_reg_spec '[' expression ']' { 
      $$ = clone_reg_as_single_with_offset($1, container_to_simm_ptr($3)->getValue());
    }
/*    | single_reg_spec ':' single_reg_spec {  */
/*        $$ = combine_single_regs_into_multi_reg($1, $3); */
/*      } */
  | baseof    { $$ = $1; }
  | regof     { $$ = $1; }
  ;

/* 
 * The DEPB and EXTB forms warrant some explanation.  In some forms,
 * "bitop_reg_spec" can only be a "mappath", namely where it is meant
 * to resolve to a bitfield (which supplies both regsiter and
 * bit-number).  Unfortunately, we could not just use "mappath" in
 * these forms, because "bitop_reg_spec" also necessarily can be a
 * "mappath", namely when the programmer wants it to resolve to a
 * register (and explicitly supplies the bit-number).  If we used
 * "mappath" for the cases where we intend the thing to be a bitfield,
 * we end up directing the parse down a path where it can only resolve
 * as a bitfield, and it "loses" the whole other path, the
 * mappath-as-register cases (yacc reports this as a whole pile of
 * reduce/reduce conflicts).  The only way to successfully handle this
 * problem is to use a generic intermediate rule "bitop_reg_spec" and
 * then semantically check in the action code that the thing is really
 * what we want.
 *
 * Along similar lines, "bitop_small_int" stands in for either bit# or
 * #bits depending on the context, and the action code has to do the
 * right thing with it.  We tried using separate productions
 * "bitop_bitpos" and "bitop_numbits", but ran into potentially
 * serious shift/reduce conflicts.  
 *
 * I should also explain the "hungarian" notation on the handler function
 * names,
 *   R = register
 *   B = bit#
 *   F = field
 *   N = #bits
 *
 * The names would have been ridiculously long if I typed them all
 * way out.
 *
 * I realize I could have used overloaded functions in C++, but I find it
 * easier to locate them with the hungarian names rather than having to 
 * inspect the argument lists.
 */
depb_form: bitop_reg_spec   bitop_small_int    bitop_reg_spec   bitop_small_int    bitop_small_int  { $$ = handle_depb_form_RBRBN($1, $2, $3, $4, $5); }
         | bitop_reg_spec   bitop_small_int    bitop_reg_spec   bitop_small_int                     { $$ = handle_depb_form_RBFN($1, $2, $3, $4); }
         | bitop_reg_spec   bitop_small_int    bitop_reg_spec                                       { $$ = handle_depb_form_RBF($1, $2, $3); }
         | bitop_reg_spec                      bitop_reg_spec   bitop_small_int    bitop_small_int  { $$ = handle_depb_form_FRBN($1, $2, $3, $4); }
         | bitop_reg_spec                      bitop_reg_spec   bitop_small_int                     { $$ = handle_depb_form_FRB($1, $2, $3); }
         | bitop_reg_spec                      bitop_reg_spec                                       { $$ = handle_depb_form_FF($1, $2); }
         ;

extb_form: bitop_reg_spec   bitop_small_int    bitop_reg_spec   bitop_small_int    bitop_small_int  { $$ = handle_extb_form_RBRBN($1, $2, $3, $4, $5); }
         | bitop_reg_spec   bitop_small_int    bitop_reg_spec   bitop_small_int                     { $$ = handle_extb_form_RBFN($1, $2, $3, $4); }
         | bitop_reg_spec                      bitop_reg_spec   bitop_small_int    bitop_small_int  { $$ = handle_extb_form_FRBN($1, $2, $3, $4); }
         | bitop_reg_spec                      bitop_reg_spec   bitop_small_int                     { $$ = handle_extb_form_FRB($1, $2, $3); }
         | bitop_reg_spec                      bitop_reg_spec                                       { $$ = handle_extb_form_FF($1, $2); }
         ;

depbi_form: imm9  reg_spec  bitop_small_int  bitop_small_int  { $$ = handle_depbi_form1($1, $2, $3, $4); }
          | imm9  reg_spec                               { $$ = handle_depbi_form2($1, $2); }
          ;

test_form: reg_spec  bitop_small_int  { $$ = handle_test_form1($1, $2); }
         | reg_spec                   { $$ = handle_test_form2($1); }
         ;

section_flags: /* empty */
             | CODE_TOKEN { }
             ;

org_fill_value : /* empty */ { $$ = -1; }
               | CONSTANT_TOKEN 
                 { 
		   if($1 > 0xff)
		     {
		       parseAlo->logException(shared_ptr<OutOfRangeOperand>
					      (new OutOfRangeOperand(".org fill value out of range",
								     get_src_line(),
								     get_src_file(), 
								     __LINE__, __FILE__)));

		       $$ = 0; // Pass 0 back up the stack to satisfy 
		               // the return requirements of this parse rule
		     }
		   else
		     {
		       $$ = $1;
		     }
                 }
                 ;

/* Type creation rules (structures, elements, bitfields). */
top_level_structure_definition: structure_definition 
            {
              assert(structure_stack.empty());
            }
            ;

structure_definition: structure_directive
           struct_contents
           ends_directive 
           { 
           }
           ;

structure_directive: STRUCTURE_TOKEN IDENTIFIER_TOKEN newline 
                   {
		     NEW(StructContainer, sc);
		     /* Create from structure if structure_stack is non-empty. */
		     if (structure_stack.size())
		       {
			 sc->st = structure_stack.top()->createStruct($2);
		       }
		     else 
		       {
			 sc->st = llirFactory->createStruct($2);
		       }
		     d_printf("New structure %s\n", $2);
		     structure_stack.push(sc->st);
		     g_currentBlock->addLlirNode(g_currentBlock, 
						 llirFactory->createStructBeginDirective(get_node_line(), 
										    get_src_line(),
										    get_src_file(), $2));
                     $$ = sc;
		     d_printf("structure_directive [%s]: size = %d\n", $2, structure_stack.size());
                   }
                   ;

struct_contents: /* empty */ { }
               | struct_contents struct_content 
                 { 
                 }
               ;

struct_content: element_directive field_list newline 
                { 
		  structure_add_type(structure_stack.top(), current_element);
                  d_printf("Adding element to %s\n", structure_stack.top()->getName().c_str());
                  g_currentBlock->addLlirNode(g_currentBlock,
					      llirFactory->createElementDirective(get_node_line(), 
										  get_src_line(),
										  get_src_file(), 
										  current_element));                
                }
              | structure_definition 
                { 
                }
              ;

element_directive: ELEMENT_TOKEN 
                   { 
		     current_element = structure_stack.top()->createElement(); 
		   }
                 ;

field_list: field_identifier 
            { 
            }
          | field_list COMMA_TOKEN field_identifier 
            { 
            }
          | field_list COMMA_TOKEN newline field_identifier 
            { 
            }
          ;

field_identifier: IDENTIFIER_TOKEN 
                  {
                    current_field = current_element->createField($1);
		    d_printf("Adding field %s\n", $1);
		    element_add_type(current_element, current_field);
                  }
                | IDENTIFIER_TOKEN '(' CONSTANT_TOKEN ':' CONSTANT_TOKEN ')' 
                  { 

		    unsigned int hi_bit = $3; 
		    unsigned int lo_bit = $5;

		     if ((lo_bit > hi_bit) || (hi_bit > 31) || (lo_bit > 31))
		       {
			 char lobuf[32];
			 char hibuf[32];

			 sprintf(lobuf, "%d", lo_bit);
			 sprintf(hibuf, "%d", hi_bit);

			 string s = string("invalid range for bitfield (") + hibuf + string(":") + lobuf + string(")");
			 parseAlo->logException(shared_ptr<OutOfRangeOperand>(new OutOfRangeOperand(s.c_str(),
												    get_src_line(),
												    get_src_file(), 
												    __LINE__, __FILE__)));
		       }
		     else
		       {
			 d_printf("Adding bitfield %s[%ld:%ld]\n", $1, $3, $5);
			 current_bitfield = current_element->createField($1, $3, $5); 
			 element_add_type(current_element, current_bitfield);
		       }
 		  }
                ;

ends_directive: ENDSTRUCTURE_TOKEN newline 
                { 
		    last_structure_popped = structure_stack.top(); 
		    d_printf("Popping %s\n",  last_structure_popped->getName().c_str());
		    g_currentBlock->addLlirNode(g_currentBlock, 
						llirFactory->createStructEndDirective(get_node_line(), 
										      get_src_line(),
										      get_src_file()));
		    structure_stack.pop(); 
		    d_printf("structure stack contains %d elements\n", structure_stack.size());
		    if (structure_stack.size() == 0)
		      {
			d_printf("Adding structure to g_currentBlock\n");
			AddOctaveSymbol(last_structure_popped); 
		      }
		    else
		      {
			d_printf("Adding structure to parent structure\n");
			structure_add_type(structure_stack.top(), last_structure_popped); 
		      }
		    d_printf("ends_directive: size = %d\n", structure_stack.size());
                 }
                ;


generic_assembler_directive : IF_TOKEN constant_expression newline 
                      { 
			conditional_if(container_to_simm_ptr($2)->getValue());
		      }
                    | ELSEIF_TOKEN constant_expression newline
                      {  
			conditional_elseif(container_to_simm_ptr($2)->getValue());
		      }
                    | ELSE_TOKEN newline
                      {  
			conditional_else();
		      }
                    | ENDIF_TOKEN newline
                      { 
			conditional_endif();
		      }
                    | MAP_TOKEN type_or_typepath_or_mapping_or_mappath IDENTIFIER_TOKEN reg_spec newline 
                      { 
		        do_mapping($2, $3, $4->regPtr); 
		      }
                    | MAP_TOKEN type_or_typepath_or_mapping_or_mappath IDENTIFIER_TOKEN sregister_multireg newline 
                      { 
		        do_mapping($2, $3, $4->regPtr); 
		      }
                    | UNMAP_TOKEN IDENTIFIER_TOKEN newline 
                      {  
			undo_mapping($2); 
		      }
                    | SECTION_TOKEN IDENTIFIER_TOKEN section_flags newline
                      { 
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createNamedSection(get_node_line(), 
												    get_src_line(),
												    get_src_file(), $2)); 
		      }
                    | BLOCK_TOKEN newline 
                      { 
			create_block(); 
		      }
                    | BLOCK_TOKEN IDENTIFIER_TOKEN newline 
                      { 
			create_block($2); 
		      }
                    | ENDBLOCK_TOKEN newline 
                      { 
			end_block(); 
		      }
                    | ENDBLOCK_TOKEN IDENTIFIER_TOKEN newline 
                      { 
			end_block($2); 
		      }
                    | TEXT_TOKEN newline 
                      { 
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createTextSection(get_node_line(), 
												   get_src_line(),
												   get_src_file())); 
		      }
                    | DATA_TOKEN newline
                      { 
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createDataSection(get_node_line(), 
												   get_src_line(),
												   get_src_file())); 
		      }
                    | LIST_TOKEN newline
                      { 
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createListDirective(get_node_line(), 
												     get_src_line(),
												     get_src_file())); 
		      }
                    | NOLIST_TOKEN newline
                      { 
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createNoListDirective(get_node_line(), 
												       get_src_line(),
												       get_src_file())); 
		      }
                    | LCOMM_TOKEN IDENTIFIER_TOKEN COMMA_TOKEN CONSTANT_TOKEN
                      { 
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createLcommSection(get_node_line(), 
												    get_src_line(),
												    get_src_file(), $2, $4)); 
		      }
                    | COMM_TOKEN IDENTIFIER_TOKEN COMMA_TOKEN CONSTANT_TOKEN
                      { 
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createCommSection(get_node_line(), 
												   get_src_line(),
												   get_src_file(), $2, $4)); 
		      }
                    | ASCII_TOKEN QUOTED_STRING_TOKEN newline
                      { 
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createAsciiDirective(get_node_line(), 
												      get_src_line(),
												      get_src_file(), $2)); 
		      }
                    | byte_token byte_list newline 
                      { 
                      }
                    | halfword_token halfword_list newline 
                      { 
                      }
                    | word_token word_list newline 
                      { 
                      }
                    | ALIGN_TOKEN align_val
                      { 
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createAlignDirective(get_node_line(), 
												      get_src_line(),
												      get_src_file(), $2)); 
		      }
/*		     | SET IDENTIFIER_TOKEN '=' expression   see PR1153 and PR1117 */
                    | REF_TOKEN IDENTIFIER_TOKEN newline
                      { 
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createRefDirective(get_node_line(), 
												    get_src_line(),
												    get_src_file(), $2)); 
		      }
		    | STABS_TOKEN QUOTED_STRING_TOKEN COMMA_TOKEN CONSTANT_TOKEN COMMA_TOKEN CONSTANT_TOKEN COMMA_TOKEN CONSTANT_TOKEN COMMA_TOKEN IDENTIFIER_TOKEN 
                      { 
		      }
		    | STABS_TOKEN QUOTED_STRING_TOKEN COMMA_TOKEN CONSTANT_TOKEN COMMA_TOKEN CONSTANT_TOKEN COMMA_TOKEN CONSTANT_TOKEN COMMA_TOKEN CONSTANT_TOKEN 
                      { 
		      }
		    | STABN_TOKEN CONSTANT_TOKEN COMMA_TOKEN CONSTANT_TOKEN COMMA_TOKEN CONSTANT_TOKEN COMMA_TOKEN IDENTIFIER_TOKEN 
                      {
		      }
		    | STABD_TOKEN CONSTANT_TOKEN COMMA_TOKEN CONSTANT_TOKEN COMMA_TOKEN CONSTANT_TOKEN 
                      {
		      }
                    | MACRO_TOKEN MACRO_LINE_DELIMITER_TOKEN
                      {  
			macro_line_delimiter_seen = 1; create_macro_block(); 
		      }
                    | ENDMACRO_TOKEN
                      { 
			end_macro_block(); 
		      }
                  /*    | DEFMACRO_TOKEN defmacro_args ignored_defmacro_body ENDDEF_TOKEN { defmacro_complete(); } */
                    | ORG_TOKEN CONSTANT_TOKEN org_fill_value  
                      { 
			if ($3 == -1)
                          g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createOrgDirective(get_node_line(), 
												      get_src_line(),
												      get_src_file(), $2));
			else
                          g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createOrgDirective(get_node_line(), 
												      get_src_line(),
												      get_src_file(), $2, (unsigned int) $3));
		      }
                    | MEETS_TOKEN type_or_map_string type_or_map_string
                      {
			if(compareStruct($2, $3) == false)
			  {
			    string s = string($2) + " does not meet " + string($3);
			    parseAlo->logException(shared_ptr<WarningDirectiveException>(new WarningDirectiveException(s.c_str(),
														       get_src_line(), 
														       get_src_file(), 
														       __LINE__, __FILE__)));
			  }

			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createMeetsDirective(get_node_line(), 
												      get_src_line(),
												      get_src_file(), $2, $3));

		      }
		    | WARNING_TOKEN  QUOTED_STRING_TOKEN
		      {
			parseAlo->logException(shared_ptr<WarningDirectiveException>(new WarningDirectiveException($2,
														   get_src_line(), 
														   get_src_file(), 
														   __LINE__, __FILE__)));
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createWarningDirective(get_node_line(), 
													get_src_line(),
													get_src_file(), $2));
		      }
		    | ERROR_TOKEN QUOTED_STRING_TOKEN
		      {
			parseAlo->logException(shared_ptr<ErrorDirectiveException>(new ErrorDirectiveException($2,
													       get_src_line(), 
													       get_src_file(), 
													       __LINE__, __FILE__)));

			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createErrorDirective(get_node_line(), 
												      get_src_line(),
												      get_src_file(), $2));
		      }
		    | ASSERT_DIRECTIVE_TOKEN constant_expression QUOTED_STRING_TOKEN
		      {
			assert_directive_check($2, $3);
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createAssertDirective(get_node_line(), 
												       get_src_line(),
												       get_src_file(), 
												       $2->exprPtr, 
												       $3));
		      }
		    | ASSERT_DIRECTIVE_TOKEN constant_expression 
		      {
			assert_directive_check($2, NULL);
			g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createAssertDirective(get_node_line(), 
												       get_src_line(),
												       get_src_file(), 
												       $2->exprPtr, 
												       ""));
		      }                    
                    ;



/* Intermediate rules for optional flags, etc: */

/* This must return a pair of flagptr objects, either of which can be Null. */
optional_mod_abc: /* empty */ {  NEW(OptionalModAbcContainer, p);
	                  p->mod_flag = llirFactory->createNullOperand();
	                  p->abc_flag = llirFactory->createNullOperand();
			  $$ = p;}
             | mod_flag { NEW(OptionalModAbcContainer, p);
	                  p->mod_flag = llirFactory->createModFlag((OctaveFactory::Mod)$1);
	                  p->abc_flag = llirFactory->createNullOperand();
			  $$ = p;
			 }
             | abc_flag { NEW(OptionalModAbcContainer, p);
	                  p->mod_flag = llirFactory->createNullOperand();
	                  p->abc_flag = llirFactory->createAbcFlag((OctaveFactory::Abc)$1);
			  $$ = p;
			 }
             | mod_flag abc_flag { NEW(OptionalModAbcContainer, p);
	                  p->mod_flag = llirFactory->createModFlag((OctaveFactory::Mod)$1);
	                  p->abc_flag = llirFactory->createAbcFlag((OctaveFactory::Abc)$2);
			  $$ = p;
			 }
             | abc_flag mod_flag { NEW(OptionalModAbcContainer, p);
	                  p->abc_flag = llirFactory->createAbcFlag((OctaveFactory::Abc)$1);
	                  p->mod_flag = llirFactory->createModFlag((OctaveFactory::Mod)$2);
			  $$ = p;
			 }
             ;

optional_mod_abc_compare: /* empty */ {  NEW(OptionalModAbcCompareContainer, p);
	                  p->mod_flag = llirFactory->createNullOperand();
	                  p->abc_compare_flag = llirFactory->createNullOperand();
			  $$ = p;}
             | mod_flag { NEW(OptionalModAbcCompareContainer, p);
	                  p->mod_flag = llirFactory->createModFlag((OctaveFactory::Mod)$1);
	                  p->abc_compare_flag = llirFactory->createNullOperand();
			  $$ = p;
			 }
             | abc_compare_flag { NEW(OptionalModAbcCompareContainer, p);
	                  p->mod_flag = llirFactory->createNullOperand();
	                  p->abc_compare_flag = llirFactory->createAbcCompareFlag((OctaveFactory::AbcCompare)$1);
			  $$ = p;
			 }
             | mod_flag abc_compare_flag { NEW(OptionalModAbcCompareContainer, p);
	                  p->mod_flag = llirFactory->createModFlag((OctaveFactory::Mod)$1);
	                  p->abc_compare_flag = llirFactory->createAbcCompareFlag((OctaveFactory::AbcCompare)$2);
			  $$ = p;
			 }
             | abc_compare_flag mod_flag { NEW(OptionalModAbcCompareContainer, p);
	                  p->abc_compare_flag = llirFactory->createAbcCompareFlag((OctaveFactory::AbcCompare)$1);
	                  p->mod_flag = llirFactory->createModFlag((OctaveFactory::Mod)$2);
			  $$ = p;
			 }
             ;

optional_abc_compare_sign:  /* empty */ {
	       NEW(OptionalAbcCompareSignContainer, p);
	       p->abc_compare_flag = llirFactory->createNullOperand();
	       p->sign_flag = llirFactory->createNullOperand();
	       $$ = p;
	     }
	     | abc_compare_flag {
	       NEW(OptionalAbcCompareSignContainer, p);
	       p->abc_compare_flag = llirFactory->createAbcCompareFlag((OctaveFactory::AbcCompare)$1);
	       p->sign_flag = llirFactory->createNullOperand();
	       $$ = p;
	     }
	     | SIGN_BIT_TOKEN {
	       NEW(OptionalAbcCompareSignContainer, p);
	       p->abc_compare_flag = llirFactory->createNullOperand();
	       p->sign_flag = llirFactory->createSignFlag();
	       $$ = p;
	     }
	     | abc_compare_flag SIGN_BIT_TOKEN {
	       NEW(OptionalAbcCompareSignContainer, p);
	       p->abc_compare_flag = llirFactory->createAbcCompareFlag((OctaveFactory::AbcCompare)$1);
	       p->sign_flag = llirFactory->createSignFlag();
	       $$ = p;
	     }
	     | SIGN_BIT_TOKEN abc_compare_flag {
	       NEW(OptionalAbcCompareSignContainer, p);
	       p->abc_compare_flag = llirFactory->createAbcCompareFlag((OctaveFactory::AbcCompare)$2);
	       p->sign_flag = llirFactory->createSignFlag();
	       $$ = p;
	     }
             ;

optional_abc_zb: /* empty */ { NEW(OptionalAbcZbitContainer, p);
               p->abc_flag = llirFactory->createNullOperand();
	       p->zbit = llirFactory->createNullOperand();
	       $$ = p; }
	       | ZB_TOKEN abc_flag  
                 { 
		   NEW(OptionalAbcZbitContainer, p);
		   p->abc_flag = llirFactory->createAbcFlag((OctaveFactory::Abc)$2);
		   p->zbit = llirFactory->createFindFlag();
		   $$ = p; 
		 }
	       | abc_flag ZB_TOKEN
                 { 
		   NEW(OptionalAbcZbitContainer, p);
		   p->abc_flag = llirFactory->createAbcFlag((OctaveFactory::Abc)$1);
		   p->zbit = llirFactory->createFindFlag();
		   $$ = p; 
		 }
	       | abc_flag
                 { 
		   NEW(OptionalAbcZbitContainer, p);
		   p->abc_flag = llirFactory->createAbcFlag((OctaveFactory::Abc)$1);
		   p->zbit = llirFactory->createNullOperand();
		   $$ = p; 
		 }
	       | ZB_TOKEN
                 { 
		   NEW(OptionalAbcZbitContainer, p);
		   p->abc_flag =  llirFactory->createNullOperand();
		   p->zbit = llirFactory->createFindFlag();
		   $$ = p; 
		 }
               ;

optional_abc_flag: /* empty */ 
               {  
		 NEW(OptionalAbcContainer, p);
		 p->abc_flag = llirFactory->createNullOperand();
		 $$ = p;
	       }
             | abc_flag 
               { 
		 NEW(OptionalAbcContainer, p);
		 p->abc_flag = llirFactory->createAbcFlag((OctaveFactory::Abc)$1);
		 $$ = p;
	       }
             ;

optional_depb_flag: /* empty */ {  NEW(OptionalDepbFlagContainer, p);
	                  p->zbit = llirFactory->createNullOperand();
			  $$ = p;}
             | Z_BIT_TOKEN { NEW(OptionalDepbFlagContainer, p);
	                  p->zbit = llirFactory->createDepbFlag();
			  $$ = p;
			 }
             ;

optional_sign_flag: /* empty */ {  NEW(OptionalSignFlagContainer, p);
	                  p->sign_flag = llirFactory->createNullOperand();
			  $$ = p;}
             | SIGN_BIT_TOKEN { NEW(OptionalSignFlagContainer, p);
	                  p->sign_flag = llirFactory->createSignFlag();
			  $$ = p;
			 }
             ;

optional_cycs_flag: /* empty */ {  NEW(OptionalCycsFlagContainer, p);
	                  p->cycs = llirFactory->createNullOperand();
			  $$ = p;}
             | cycs_flag { NEW(OptionalCycsFlagContainer, p);
	                  p->cycs = llirFactory->createMvhFlag((OctaveFactory::Mvh)$1);
			  $$ = p;
			 }
             ;

optional_hec_flag:  /* empty */ {  NEW(OptionalHecFlagContainer, p);
	                  p->cume = llirFactory->createNullOperand();
			  $$ = p;}
             | HC_TOKEN { NEW(OptionalHecFlagContainer, p);
                          p->cume = llirFactory->createCumeFlag();
			  $$ = p;
			 }
             ;

optional_sx_flag:  /* empty */ {  NEW(OptionalSxFlagContainer, p);
	                  p->sx_flag = llirFactory->createNullOperand();
			  $$ = p;}
             | SX_TOKEN { NEW(OptionalSxFlagContainer, p);
	                  p->sx_flag = llirFactory->createSXFlag();
			  $$ = p;
			 }
             ;

optional_di_flag:  /* empty */ {  NEW(OptionalDiFlagContainer, p);
	                  p->di_flag = llirFactory->createNullOperand();
			  $$ = p;}
             | DI_TOKEN { NEW(OptionalDiFlagContainer, p);
                          p->di_flag = llirFactory->createDIFlag();
			  $$ = p;
			 }
             ;

optional_reg: /* empty */ { 
	         NEW(OptionalRegContainer, p);
		 p->reg = llirFactory->createNullOperand();
		 $$ = p;		 
	       }
             | REGISTER_TOKEN {
	         NEW(OptionalRegContainer, p);
		 p->reg = llirFactory->createHardReg($1); 
		 $$ = p;
	       }
            ;

optional_branch_disp: /* empty */ { 
		 NEW(OptionalBranchDispContainer, p);
		 p->branch_disp = llirFactory->createNullOperand();
		 $$ = p;
	       }
               | BR_TOKEN '=' expression { 
	         NEW(OptionalBranchDispContainer, p);
		 p->branch_disp = container_check_branch_expr($3);
		 $$ = p;
	       }
               ;

optional_branch_disp_with_abc: /* empty */ { 
	         NEW(OptionalBranchDispWithAbcContainer, p);
		 p->branch_disp = llirFactory->createNullOperand();
		 p->abc_flag = llirFactory->createNullOperand();
		 $$ = p;
	       }
               | BR_TOKEN '=' expression abc_compare_flag {
		 NEW(OptionalBranchDispWithAbcContainer, p);
		 p->branch_disp =  container_check_branch_expr($3);
		 p->abc_flag = llirFactory->createAbcCompareFlag((OctaveFactory::AbcCompare)$4);
		 $$ = p;
	       }
               ;


/* Generic processor instructions (common to all chips). */
generic_processor_instruction: 
                       ADD_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, $3->regPtr,
									$4->regPtr, $5->abc_flag, $5->mod_flag);
			 $$ = p;
                       }
                     | ADD_TOKEN error newline 
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADDC_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddcInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->regPtr, 
									 $4->regPtr, $5->abc_flag, $5->mod_flag);
			 $$ = p;
                       }
                     | ADDC_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADD4X_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAdd4xInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, $3->regPtr, 
									  $4->regPtr, $5->abc_flag, $5->mod_flag);
			 $$ = p;
                        }
                     | ADD4X_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADDNE_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddneInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, $3->regPtr, 
									  $4->regPtr);
			 $$ = p;
		       }
                     | ADDNE_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | AND_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAndInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, $3->regPtr, 
									$4->regPtr, $5->abc_flag, $5->mod_flag);
			 $$ = p;
                         }
                     | AND_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | OR_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createOrInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, $3->regPtr, 
								       $4->regPtr, $5->abc_flag, $5->mod_flag);
			 $$ = p;
                         }
                     | OR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SUB_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, $3->regPtr,
									$4->regPtr, $5->abc_flag, $5->mod_flag);
			 $$ = p;
                         }
                     | SUB_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SUBB_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubbInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->regPtr,
									 $4->regPtr, $5->abc_flag, $5->mod_flag);
			 $$ = p;
                         }
                     | SUBB_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | XOR_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createXorInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, $3->regPtr,
									$4->regPtr, $5->abc_flag, $5->mod_flag);
			 $$ = p;
                         }
                     | XOR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SETB_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_abc_flag newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSetbInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->regPtr,
									 $4->regPtr, $5->abc_flag);
			 $$ = p;
                         }
                     | SETB_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | CLRB_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_abc_flag newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createClrbInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->regPtr, 
									 $4->regPtr, $5->abc_flag);
			 $$ = p;
                         }
                     | CLRB_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | CLRBI_TOKEN single_reg_spec sft_imm5 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createClrbiInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
									$4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | CLRBI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | RAND_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_abc_flag newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createRandInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->regPtr,
									 $4->regPtr, $5->abc_flag);
			 $$ = p;
                         }
                     | RAND_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
		    /* ALUI flavor instructions */
                     | ADDI_TOKEN single_reg_spec imm6 single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddiInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
									 $4->regPtr, $5->abc_flag, $5->mod_flag);
			 $$ = p;
                         }
                     | ADDI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADDCI_TOKEN single_reg_spec imm6 single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddciInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
                                                                          $4->regPtr, $5->abc_flag, $5->mod_flag);
                         $$ = p;
                         }
                     | ADDCI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADDNEI_TOKEN single_reg_spec imm6 single_reg_spec newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddneiInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
									   $4->regPtr);
                         $$ = p;
                         }
                     | ADDNEI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SUBI_TOKEN single_reg_spec imm6 single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubiInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
									 $4->regPtr, $5->abc_flag, $5->mod_flag);
                         $$ = p;
                         }
                     | SUBI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SUBBI_TOKEN single_reg_spec imm6 single_reg_spec optional_mod_abc newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubbiInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
									  $4->regPtr, $5->abc_flag, $5->mod_flag);
                         $$ = p;
                         }
                     | SUBBI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | RANDI_TOKEN single_reg_spec imm6 single_reg_spec optional_abc_flag newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createRandiInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
                                                                          $4->regPtr, $5->abc_flag);
                         $$ = p;
                         }
                     | RANDI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
		    /* ADDL_TOKEN flavor instructions. */
                     | ADDL_TOKEN single_reg_spec single_reg_spec optional_branch_disp newline { 
                         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createAddlInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->regPtr,
									 $4->branch_disp);
			 $$ = p;
                         }
                     | ADDL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADDWH_TOKEN single_reg_spec single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddwhInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, $3->regPtr,
									  $4->branch_disp);
                         $$ = p;
                         }
                     | ADDWH_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADDWL_TOKEN single_reg_spec single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddwlInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, $3->regPtr,
									  $4->branch_disp);
                         $$ = p;
                         }
                     | ADDWL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADDWW_TOKEN single_reg_spec single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddwwInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, $3->regPtr,
									  $4->branch_disp);
                         $$ = p;
                         }
                     | ADDWW_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SUBL_TOKEN single_reg_spec single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSublInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->regPtr,
                                                                         $4->branch_disp);
                         $$ = p;
                         }
                     | SUBL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SUBWH_TOKEN single_reg_spec single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubwhInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, $3->regPtr,
									  $4->branch_disp);
                         $$ = p;
                         }
                     | SUBWH_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
										    get_src_line(),
										    get_src_file());
			 $$ = p;
		       }
                     | SUBWL_TOKEN single_reg_spec single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubwlInstruction(get_node_line(), 
										    get_src_line(),
										    get_src_file(), $2->regPtr, $3->regPtr,
									  $4->branch_disp);
                         $$ = p;
                         }
                     | SUBWL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SUBWW_TOKEN single_reg_spec single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubwwInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, $3->regPtr,
                                                                         $4->branch_disp);
                         $$ = p;
                         }
                     | SUBWW_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
		    /* ADDLI_TOKEN flavor instructions. */
                     | ADDLI_TOKEN imm6 single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddliInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), container_to_uimm_ptr($2),
									  $3->regPtr, $4->branch_disp);
                         $$ = p;
                         }

                     | ADDLI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADDWHI_TOKEN imm6 single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddwhiInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file(), container_to_uimm_ptr($2),
									   $3->regPtr,$4->branch_disp);
                         $$ = p;
                         }
                     | ADDWHI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADDWLI_TOKEN imm6 single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddwliInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file(), container_to_uimm_ptr($2),
									   $3->regPtr,$4->branch_disp);
                         $$ = p;
                         }
                     | ADDWLI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ADDWWI_TOKEN imm6 single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createAddwwiInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file(), container_to_uimm_ptr($2),
									   $3->regPtr, $4->branch_disp);
                         $$ = p;
                         }
                     | ADDWWI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SUBLI_TOKEN imm6 single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubliInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), container_to_uimm_ptr($2),
                                                                          $3->regPtr, $4->branch_disp);
                         $$ = p;
                         }
                     | SUBLI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
										    get_src_line(),
										    get_src_file());
			 $$ = p;
		       }
                     | SUBWHI_TOKEN imm6 single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubwhiInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file(), container_to_uimm_ptr($2),
									   $3->regPtr, $4->branch_disp);
                         $$ = p;
                         }
                     | SUBWHI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SUBWLI_TOKEN imm6 single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubwliInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file(), container_to_uimm_ptr($2),
									   $3->regPtr, $4->branch_disp);
                         $$ = p;
                         }
                     | SUBWLI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SUBWWI_TOKEN imm6 single_reg_spec optional_branch_disp newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createSubwwiInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file(), container_to_uimm_ptr($2),
									   $3->regPtr, $4->branch_disp);
                         $$ = p;
                         }
                     | SUBWWI_TOKEN error newline  newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BCDI_TOKEN expression cond_branch_args newline {
		         NEW(OctaveInsnContainer, p);
			 $3->finalize();

			 p->insnPtr = llirFactory->createBcdiInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(),
									 container_check_branch_expr($2),
									 $3->ess,
									 $3->rd,
									 $3->flags);

			 $$ = p;
		         }
                     | BCDI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BCDR_TOKEN single_reg_spec cond_branch_args newline {
		         NEW(OctaveInsnContainer, p);
			 $3->finalize();
			 p->insnPtr = llirFactory->createBcdrInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(),
									 $2->regPtr,
									 $3->ess,
									 $3->rd,
									 $3->flags);
			 $$ = p;
		         }
                     | BCDR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BCI_TOKEN expression cond_branch_args newline {
		         NEW(OctaveInsnContainer, p);
			 $3->finalize();
			 p->insnPtr = llirFactory->createBciInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(),
									container_check_branch_expr($2),
									$3->ess,
									$3->rd,
									$3->flags);
			 $$ = p;
		         }
                     | BCI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BCR_TOKEN single_reg_spec cond_branch_args newline {
		         NEW(OctaveInsnContainer, p);
			 $3->finalize();
			 p->insnPtr = llirFactory->createBcrInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(),
									$2->regPtr,
									$3->ess,
									$3->rd,
									$3->flags);
			 $$ = p;
		         }
                     | BCR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BI_TOKEN expression bi_arg_set newline {
		         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createBiInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(),
								       container_check_branch_expr($2),
								       $3->rd,
								       $3->cd_flag);

			 $$ = p;
 		         }
                     | BI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }

                     | BNZR_TOKEN single_reg_spec single_reg_spec optional_reg newline {
                          NEW(OctaveInsnContainer, p);
                          p->insnPtr = llirFactory->createBnzrInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(),
									  $2->regPtr,
									  $3->regPtr,
									  $4->reg);
                         $$ = p;
		     }
                     | BNZR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }

                     | BNZI_TOKEN single_reg_spec expression optional_reg newline {
                          NEW(OctaveInsnContainer, p);
                          p->insnPtr = llirFactory->createBnziInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(),
									  $2->regPtr,
									  container_check_branch_expr($3),
									  $4->reg);

                         $$ = p;
		     }
                     | BNZI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BR_TOKEN single_reg_spec optional_reg newline {
		         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createBrInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(),
									$2->regPtr,
									$3->reg);
			 $$ = p;
 		         }
                     | BR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BRS_TOKEN optional_reg newline {
		         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createBrsInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(),
									$2->reg);
			 $$ = p;
 		         }
                     | BRS_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BRSL_TOKEN brsl_arg_set newline {
		         NEW(OctaveInsnContainer, p);
			 current_brsl_arg_set->finalize();
                         p->insnPtr = llirFactory->createBrslInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(),
                                                                         $2->flags);
                         $$ = p;
		       }
                     | BRSL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BRSPRE_TOKEN newline {
		         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createBrspreInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file());
			 $$ = p;
		       }
                     | BRSPRE_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BYTESW_TOKEN single_reg_spec single_reg_spec bytesel0 bytesel1 bytesel2 bytesel3 optional_abc_flag newline {
		         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createByteswInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file(),
									   $2->regPtr,
									   $3->regPtr,
									   container_to_uimm_ptr($4),
									   container_to_uimm_ptr($5),
									   container_to_uimm_ptr($6),
									   container_to_uimm_ptr($7),
									   $8->abc_flag);
                         $$ = p;
		       }
                     | BYTESW_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BZR_TOKEN single_reg_spec single_reg_spec optional_reg newline {
		          NEW(OctaveInsnContainer, p);
			  p->insnPtr = llirFactory->createBzrInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(),
									 $2->regPtr,
									 $3->regPtr,
									 $4->reg);
                         $$ = p;
		       }
                     | BZR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | BZI_TOKEN single_reg_spec expression optional_reg newline {
                          NEW(OctaveInsnContainer, p);
                          p->insnPtr = llirFactory->createBziInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(),
                                                                         $2->regPtr,
                                                                         container_check_branch_expr($3),
									 $4->reg);

                         $$ = p;
		     }
                     | BZI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | CMOV_TOKEN single_reg_spec single_reg_spec single_reg_spec ess newline 
                        {
                          NEW(OctaveInsnContainer, p);
                          p->insnPtr = llirFactory->createCmovInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regPtr, $3->regPtr,
									  $4->regPtr, $5->ess);
			  $$ = p;
			}
                     | CMOV_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | CMOVI_TOKEN single_reg_spec imm6 single_reg_spec ess newline
                        {
                          NEW(OctaveInsnContainer, p);
                          p->insnPtr = llirFactory->createCmoviInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
									  $4->regPtr, $5->ess);
			  $$ = p;
			}
                     | CMOVI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | MAX_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc_compare newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createMaxInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr, 
									$5->abc_compare_flag, $5->mod_flag);
			 $$ = p;
                       }
                     | MAX_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | MIN_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_mod_abc_compare newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createMinInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr, 
									$5->abc_compare_flag, $5->mod_flag);
			 $$ = p;
                        }
                     | MIN_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | CMP_TOKEN single_reg_spec single_reg_spec optional_branch_disp_with_abc newline {
		         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createCmpInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, $3->regPtr,
									$4->abc_flag, $4->branch_disp);
			 $$ = p;
   		       }
                     | CMP_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | CMPI_TOKEN single_reg_spec imm10 optional_branch_disp_with_abc newline {
		         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createCmpiInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, container_to_simm_ptr($3),
									 $4->abc_flag, $4->branch_disp);
			 $$ = p;
		       }
                     | CMPI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | CMPR_TOKEN  single_reg_spec single_reg_spec single_reg_spec optional_abc_compare_sign newline {
                         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createCmprInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr,
                                                                         $5->abc_compare_flag, $5->sign_flag);
                         $$ = p;
                       }
         	     | CMPR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | CMPRI_TOKEN single_reg_spec imm10 single_reg_spec  optional_abc_compare_sign newline {
		         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createCmpriInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), 
									  $2->regPtr, 
									  container_to_simm_ptr($3),
									  $4->regPtr, $5->abc_compare_flag, $5->sign_flag);
			 $$ = p;
		       }
         	     | CMPRI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | DEPB_TOKEN depb_form optional_depb_flag newline {
		         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createDepbInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(),
									 $2->src,
									 $2->srcBitNum,
									 $2->dst,    
									 $2->dstBitNum,
									 $2->numBits,
									 $3->zbit);
			 $$ = p;
		       }
                     | DEPB_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | DEPBI_TOKEN depbi_form optional_depb_flag newline {
		         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createDepbiInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(),
									  $2->src,
									  $2->dst,
									  $2->dstBitNum,
									  $2->numBits,
									  $3->zbit);
			 $$ = p;		     
		       }
                     | DEPBI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* DMAP_TOKEN flavor insns */
                     | DMASR_TOKEN unlink_form expression newline
                       {
			 NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createDmasrInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(),
									  $2->regPtr,
									  container_to_uimm_ptr($3));
			 $$ = p;
		       }
                     | DMASR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | DMAP_TOKEN unlink_form expression newline
                       {
			 NEW(OctaveInsnContainer, p);

		       
			 p->insnPtr = llirFactory->createDmapInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(),
									 $2->regPtr,
									 container_to_uimm_ptr($3));
			 $$ = p;
		       }
                     | DMAP_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | DMAU0_TOKEN  unlink_form expression newline
                       {
			 NEW(OctaveInsnContainer, p);

		       
			 p->insnPtr = llirFactory->createDmau0Instruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(),
									  $2->regPtr,
									  container_to_uimm_ptr($3));
			 $$ = p;
		       }
                     | DMAU0_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | DMAU1_TOKEN unlink_form expression newline
                       {
			 NEW(OctaveInsnContainer, p);

		       
			 p->insnPtr = llirFactory->createDmau1Instruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(),
									  $2->regPtr,
									  container_to_uimm_ptr($3));
			 $$ = p;
		       }
                     | DMAU1_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | EXTB_TOKEN extb_form optional_sign_flag newline {
		         NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createExtbInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(),
									 $2->src,
									 $2->srcBitNum,
									 $2->dst, 
									 $2->dstBitNum,
									 $2->numBits,
									 $3->sign_flag);
			 $$ = p;
		       }
                     | EXTB_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | GET_TOKEN single_reg_spec traffic_sched_flags newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createGetInstruction(get_node_line(), 
								      get_src_line(),
								      get_src_file(), $2->regPtr, $3->flags);
		       $$ = p;  
		       }
                     | GET_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | HEC5_TOKEN single_reg_spec single_reg_spec imm3 optional_hec_flag optional_branch_disp newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createHec5Instruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, $3->regPtr, container_to_uimm_ptr($4),
								       $5->cume, $6->branch_disp);
		       $$ = p; 
                       }
                     | HEC5_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | LINK_TOKEN multireg_form  optional_lnk_flag newline
                       {
			 NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createLinkInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regs, $2->mem, 
									 shared_static_cast<const LinkFlag>($3->linkFlag));
			 $$ = p;
		       }
                     | LINK_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | LINKS_TOKEN multireg_form  optional_lnk_flag newline
                       {
			 NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createLinksInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), $2->regs, $2->mem, 
									  shared_static_cast<const LinkFlag>($3->linkFlag));
			 $$ = p;
		       }
                     | LINKS_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* LMM_TOKEN */
                     | LMM_TOKEN multireg_form  optional_lnk_flag newline 
                       {
			 NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createLmmInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regs, $2->mem, $3->linkFlag);
			 $$ = p;
		       }
                     | LMM_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* LD_SCRATCH flavor insns */
                     | LMMS_TOKEN scratchpad_form  optional_lnk_flag newline {
		       NEW(OctaveInsnContainer, p);
 		       /* LMMS has always shared the same syntax as LSP. */
 		       p->insnPtr = llirFactory->createLspInstruction(get_node_line(), 
								      get_src_line(),
								      get_src_file(), $2->regs, $2->mem, $3->linkFlag);
		       $$ = p;
		     }
                     | LMMS_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | LSP_TOKEN scratchpad_form optional_lnk_flag newline {
		       NEW(OctaveInsnContainer, p);

		       p->insnPtr = llirFactory->createLspInstruction(get_node_line(), 
								      get_src_line(),
								      get_src_file(), $2->regs, $2->mem, $3->linkFlag);
		       $$ = p;
		     }
                     | LSP_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* LOGI flavor insns */
                     | ANDI_TOKEN single_reg_spec imm10 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createAndiInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, container_to_simm_ptr($3),
								       $4->regPtr, $5->abc_flag);
		       $$ = p;
		     }
                     | ANDI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ORI_TOKEN single_reg_spec imm10 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createOriInstruction(get_node_line(), 
								      get_src_line(),
								      get_src_file(), $2->regPtr, container_to_simm_ptr($3),
								      $4->regPtr, $5->abc_flag);
		       $$ = p;
		     }
                     | ORI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | XORI_TOKEN single_reg_spec imm10 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createXoriInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, container_to_simm_ptr($3),
								       $4->regPtr, $5->abc_flag);
		       $$ = p;
		     }
                     | XORI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }

                     | FLS_TOKEN single_reg_spec single_reg_spec optional_abc_zb newline {
 		         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createFlsInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(),
									$2->regPtr, $3->regPtr,
									$4->abc_flag, $4->zbit);
                         $$ = p;
		       }
                     | FLS_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | FFS_TOKEN single_reg_spec single_reg_spec optional_abc_zb newline {
 		         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createFfsInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(),
									$2->regPtr, $3->regPtr,
									$4->abc_flag, $4->zbit);
                         $$ = p;
		       }
                     | FFS_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | PAR_TOKEN single_reg_spec single_reg_spec optional_abc_flag newline {
 		         NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createParInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(),
									$2->regPtr, $3->regPtr,
									$4->abc_flag);
                         $$ = p;
		       }
                     | PAR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                    /* LIMD flavor insns */
                     | LIL_TOKEN single_reg_spec limd_imm17 newline {
		       NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createLilInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, $3->exprPtr);
                         $$ = p;
		       }
                     | LIL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | LIH_TOKEN single_reg_spec limd_imm17 newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createLihInstruction(get_node_line(), 
								      get_src_line(),
								      get_src_file(), $2->regPtr, $3->exprPtr);
                         $$ = p;
		       }
                     | LIH_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | LAIL_TOKEN single_reg_spec limd_imm17 newline {
		       NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createLailInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->exprPtr);
                         $$ = p;
		       }
                     | LAIL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | LAIH_TOKEN single_reg_spec limd_imm17 newline {
		       NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createLaihInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->exprPtr);
                         $$ = p;
		       }
                     | LAIH_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* LHIMD flavor insns */
                     | LWIL_TOKEN single_reg_spec limd_imm16 newline {
		       NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createLwilInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->exprPtr);
                         $$ = p;
		       }
                     | LWIL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | LWIH_TOKEN single_reg_spec limd_imm16 newline {
		       NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createLwihInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, $3->exprPtr);
                         $$ = p;
		       }
                     | LWIH_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* MAXI_TOKEN flavor insns */
                     | MAXI_TOKEN single_reg_spec imm10 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createMaxiInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, container_to_simm_ptr($3),
									 $4->regPtr, $5->abc_flag);
                         $$ = p;
		       }
                     | MAXI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | MINI_TOKEN single_reg_spec imm10 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createMiniInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file(), $2->regPtr, container_to_simm_ptr($3),
									 $4->regPtr, $5->abc_flag);
                         $$ = p;
		       }
                     | MINI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | MV_TOKEN single_reg_spec single_reg_spec newline {
		       NEW(OctaveInsnContainer, p);
                         p->insnPtr = llirFactory->createMvInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, $3->regPtr);
                         $$ = p;
		       }
                     | MV_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | MVRH_TOKEN single_reg_spec single_reg_spec optional_cycs_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createMvrhInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, $3->regPtr,
								       $4->cycs);
		       $$ = p;
		       }
                     | MVRH_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | MVHR_TOKEN single_reg_spec single_reg_spec optional_cycs_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createMvhrInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, $3->regPtr,
								       $4->cycs);
		       $$ = p;
		       }
                     | MVHR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* MULDIV flavor insns */
                     | MULH_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_sx_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createMulhInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr,
								       $5->sx_flag);
		       $$ = p;
		       }
                     | MULH_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | MUL_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_sx_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createMulInstruction(get_node_line(), 
								      get_src_line(),
								      get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr,
								       $5->sx_flag);
		       $$ = p;
		       }
                     | MUL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* MULDIVI flavor insns */
                     | MULHI_TOKEN single_reg_spec imm10 single_reg_spec optional_sx_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createMulhiInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, container_to_simm_ptr($3),
								       $4->regPtr, $5->sx_flag);
		       $$ = p;
		       }
                     | MULHI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | MULI_TOKEN single_reg_spec imm10 single_reg_spec optional_sx_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createMuliInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, container_to_simm_ptr($3),
								       $4->regPtr, $5->sx_flag);
		       $$ = p;
		       }
                     | MULI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* NOP_TOKEN */
                     | NOP_TOKEN newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createNopInstruction(get_node_line(), 
								      get_src_line(),
								      get_src_file());
		       $$ = p;
		       }
                     | NOP_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | POL_TOKEN single_reg_spec traffic_sched_flags newline {
                       NEW(OctaveInsnContainer, p);
                       p->insnPtr = llirFactory->createPolInstruction(get_node_line(), 
								      get_src_line(),
								      get_src_file(),
								      $2->regPtr,
								      $3->flags);
                       $$ = p; 
		       }
                     | POL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | POLC_TOKEN param_offset pos_offset traffic_sched_flags newline {
                       NEW(OctaveInsnContainer, p);
                       p->insnPtr = llirFactory->createPolcInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(),
								       container_to_uimm_ptr($2), 
								       container_to_uimm_ptr($3),
								       $4->flags);
                       $$ = p; 
		       }
                     | POLC_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* RTI flavor insns */
                     | RINT_TOKEN optional_di_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createRintInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->di_flag);
		       $$ = p;
		       }
                     | RINT_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* RTI flavor insns */
                     | RNMI_TOKEN optional_di_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createRnmiInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->di_flag);
		       $$ = p;
		       }
                     | RNMI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* SFTI flavor insns */
                     | SHRAI_TOKEN single_reg_spec sft_imm5 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createShraiInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
									$4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | SHRAI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ROTLI_TOKEN single_reg_spec sft_imm5 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createRotliInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
									$4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | ROTLI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ROTRI_TOKEN single_reg_spec sft_imm5 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createRotriInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
									$4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | ROTRI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SHRI_TOKEN single_reg_spec sft_imm5 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createShriInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
								       $4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | SHRI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SHLI_TOKEN single_reg_spec sft_imm5 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createShliInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
								       $4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | SHLI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SETBI_TOKEN single_reg_spec sft_imm5 single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createSetbiInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, container_to_uimm_ptr($3),
									$4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | SETBI_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* SHFT_TOKEN flavor insns */
                     | SHFT_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createShftInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | SHFT_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SHFTA_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createShftaInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | SHFTA_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SHRA_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createShraInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | SHRA_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ROTL_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createRotlInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | ROTL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | ROTR_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createRotrInstruction(get_node_line(), 
								       get_src_line(),
								       get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | ROTR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SHR_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createShrInstruction(get_node_line(), 
								      get_src_line(),
								      get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | SHR_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SHL_TOKEN single_reg_spec single_reg_spec single_reg_spec optional_abc_flag newline {
		       NEW(OctaveInsnContainer, p);
		       p->insnPtr = llirFactory->createShlInstruction(get_node_line(), 
								      get_src_line(),
								      get_src_file(), $2->regPtr, $3->regPtr, $4->regPtr, $5->abc_flag);
		       $$ = p;
		       }
                     | SHL_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* SMM_TOKEN */
                     | SMM_TOKEN multireg_form newline
                       {
			 NEW(OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createSmmInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regs, $2->mem);
			 $$ = p;
		       }
                     | SMM_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     /* SP_SCRATCH flavor insns */
                     | SMMS_TOKEN scratchpad_form newline
                       {
			 NEW(OctaveInsnContainer, p);
			 /* SMMS has always shared the same syntax as SSP. */
			 p->insnPtr = llirFactory->createSspInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regs, $2->mem);
			 $$ = p;
		       }
                     | SMMS_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | SSP_TOKEN scratchpad_form newline
                       {
			 NEW(OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createSspInstruction(get_node_line(), 
									get_src_line(),
									get_src_file(), $2->regs, $2->mem);
			 $$ = p;
		       }
                     | SSP_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                       /* TSTCLR flavor insns */
                     | TSETB_TOKEN test_form BR_TOKEN '=' expression newline
                       {
			 NEW (OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createTsetbInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), 
									  $2->reg,
									  $2->bitnum,
									  $5->exprPtr);
			 $$ = p;
		       }
                     | TSETB_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                       /* TSTCLR flavor insns */
                     | TCLRB_TOKEN test_form BR_TOKEN '=' expression newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createTclrbInstruction(get_node_line(), 
									  get_src_line(),
									  get_src_file(), 
									  $2->reg,
									  $2->bitnum,
									  $5->exprPtr);
			 $$ = p;
		       }
                     | TCLRB_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     | UNLINK_TOKEN unlink_form newline {
		         NEW (OctaveInsnContainer, p);
			 p->insnPtr = llirFactory->createUnlinkInstruction(get_node_line(), 
									   get_src_line(),
									   get_src_file(), $2->regPtr);
			 $$ = p;
		       }
                     | UNLINK_TOKEN error newline
                       {
			 NEW (OctaveInsnContainer, p);

			 p->insnPtr = llirFactory->createNullInstruction(get_node_line(), 
									 get_src_line(),
									 get_src_file());
			 $$ = p;
		       }
                     ;


/* </from expand_insns.py> */

mod_flag: MOD2_TOKEN  { $$ = OctaveFactory::MOD2; }
        | MOD4_TOKEN  { $$ = OctaveFactory::MOD4; }
        | MOD8_TOKEN  { $$ = OctaveFactory::MOD8; }
        | MOD16_TOKEN  { $$ = OctaveFactory::MOD16; }
        | MOD32_TOKEN  { $$ = OctaveFactory::MOD32; }
        | MOD64_TOKEN  { $$ = OctaveFactory::MOD64; }
        | MOD128_TOKEN { $$ = OctaveFactory::MOD128; }
        | MOD256_TOKEN { $$ = OctaveFactory::MOD256; }
        | MOD512_TOKEN { $$ = OctaveFactory::MOD512; }
        | MOD1K_TOKEN { $$ = OctaveFactory::MOD1K; }
        | MOD2K_TOKEN { $$ = OctaveFactory::MOD2K; }
        | MOD4K_TOKEN { $$ = OctaveFactory::MOD4K; }
        | MOD8K_TOKEN { $$ = OctaveFactory::MOD8K; }
        | MOD16K_TOKEN { $$ = OctaveFactory::MOD16K; }
        | MOD32K_TOKEN { $$ = OctaveFactory::MOD32K; }
        | MOD64K_TOKEN { $$ = OctaveFactory::MOD64K; }
        | MOD128K_TOKEN { $$ = OctaveFactory::MOD128K; }
        | MOD256K_TOKEN { $$ = OctaveFactory::MOD256K; }
        | MOD512K_TOKEN { $$ = OctaveFactory::MOD512K; }
        | MOD1M_TOKEN { $$ = OctaveFactory::MOD1M; }
        | MOD2M_TOKEN { $$ = OctaveFactory::MOD2M; }
        | MOD4M_TOKEN { $$ = OctaveFactory::MOD4M; }
        | MOD8M_TOKEN { $$ = OctaveFactory::MOD8M; }
        | MOD16M_TOKEN { $$ = OctaveFactory::MOD16M; }
        | MOD32M_TOKEN { $$ = OctaveFactory::MOD32M; }
        | MOD64M_TOKEN { $$ = OctaveFactory::MOD64M; }
        | MOD128M_TOKEN { $$ = OctaveFactory::MOD128M; }
        | MOD256M_TOKEN { $$ = OctaveFactory::MOD256M; }
        | MOD512M_TOKEN { $$ = OctaveFactory::MOD512M; }
        | MOD1G_TOKEN { $$ = OctaveFactory::MOD1G; }
        | MOD2G_TOKEN { $$ = OctaveFactory::MOD2G; }
        ;


abc_flag: BGEZ_TOKEN { $$ = OctaveFactory::BGEZ; }
        | BNC_TOKEN  { $$ = OctaveFactory::BNC; }
        | BZ_TOKEN   { $$ = OctaveFactory::BZ; }
        | BLEZ_TOKEN { $$ = OctaveFactory::BLEZ; }
        | BLZ_TOKEN  { $$ = OctaveFactory::BLZ; }
        | BNZ_TOKEN  { $$ = OctaveFactory::BNZ; }
        | BNO_TOKEN  { $$ = OctaveFactory::BNO; }
        ;

abc_compare_flag: BAGB_TOKEN { $$ = OctaveFactory::BAGB }
        | BAGEB_TOKEN { $$ = OctaveFactory::BAGEB }
        | BAEB_TOKEN  { $$ = OctaveFactory::BAEB }
        | BALEB_TOKEN { $$ = OctaveFactory::BALEB }
        | BALB_TOKEN  { $$ = OctaveFactory::BALB }
        | BANEB_TOKEN { $$ = OctaveFactory::BANEB }
        ;

cycs_flag: C0_TOKEN { $$ = OctaveFactory::C0; }
        | C1_TOKEN { $$ = OctaveFactory::C1; }
        | C2_TOKEN { $$ = OctaveFactory::C2; }
        | C3_TOKEN { $$ = OctaveFactory::C3; }
        | C4_TOKEN { $$ = OctaveFactory::C4; }
        | C5_TOKEN { $$ = OctaveFactory::C5; }
        | C6_TOKEN { $$ = OctaveFactory::C6; }
        | C7_TOKEN { $$ = OctaveFactory::C7; }
        | C8_TOKEN { $$ = OctaveFactory::C8; }
        | C9_TOKEN { $$ = OctaveFactory::C9; }
        | C10_TOKEN { $$ = OctaveFactory::C10; }
        | C11_TOKEN { $$ = OctaveFactory::C11; }
        | C12_TOKEN { $$ = OctaveFactory::C12; }
        | C13_TOKEN { $$ = OctaveFactory::C13; }
        | C14_TOKEN { $$ = OctaveFactory::C14; }
        | C15_TOKEN { $$ = OctaveFactory::C15; }
        ;


ess_flag: ESS0_TOKEN { $$ = OctaveFactory::ESS0; }
        | ESS1_TOKEN { $$ = OctaveFactory::ESS1; }
        | ESS2_TOKEN { $$ = OctaveFactory::ESS2; }
        | ESS3_TOKEN { $$ = OctaveFactory::ESS3; }
        | ESS4_TOKEN { $$ = OctaveFactory::ESS4; }
        | ESS5_TOKEN { $$ = OctaveFactory::ESS5; }
        | ESS6_TOKEN { $$ = OctaveFactory::ESS6; }
        | ESS7_TOKEN { $$ = OctaveFactory::ESS7; }
        | ESS8_TOKEN { $$ = OctaveFactory::ESS8; }
        | ESS9_TOKEN { $$ = OctaveFactory::ESS9; }
        | ESS10_TOKEN { $$ = OctaveFactory::ESS10; }
        | ESS11_TOKEN { $$ = OctaveFactory::ESS11; }
        | ESS12_TOKEN { $$ = OctaveFactory::ESS12; }
        | ESS13_TOKEN { $$ = OctaveFactory::ESS13; }
        | ESS14_TOKEN { $$ = OctaveFactory::ESS14; }
        | ESS15_TOKEN { $$ = OctaveFactory::ESS15; }
        | ESS16_TOKEN { $$ = OctaveFactory::ESS16; }
        | ESS17_TOKEN { $$ = OctaveFactory::ESS17; }
        | ESS18_TOKEN { $$ = OctaveFactory::ESS18; }
        | ESS19_TOKEN { $$ = OctaveFactory::ESS19; }
        | ESS20_TOKEN { $$ = OctaveFactory::ESS20; }
        | ESS21_TOKEN { $$ = OctaveFactory::ESS21; }
        | ESS22_TOKEN { $$ = OctaveFactory::ESS22; }
        | ESS23_TOKEN { $$ = OctaveFactory::ESS23; }
        | ESS24_TOKEN { $$ = OctaveFactory::ESS24; }
        | ESS25_TOKEN { $$ = OctaveFactory::ESS25; }
        | ESS26_TOKEN { $$ = OctaveFactory::ESS26; }
        | ESS27_TOKEN { $$ = OctaveFactory::ESS27; }
        | ESS28_TOKEN { $$ = OctaveFactory::ESS28; }
        | ESS29_TOKEN { $$ = OctaveFactory::ESS29; }
        | ESS30_TOKEN { $$ = OctaveFactory::ESS30; }
        | ESS31_TOKEN { $$ = OctaveFactory::ESS31; }
        ;

optional_lnk_flag: /* empty */{ NEW(OptionalLnkFlagContainer, lf); lf->linkFlag = llirFactory->createNullOperand(); $$ = lf; }
        | LNK1_TOKEN { NEW(OptionalLnkFlagContainer, lf); lf->linkFlag = llirFactory->createLnkFlag(OctaveFactory::LNK1); $$ = lf; }
        | LNK2_TOKEN { NEW(OptionalLnkFlagContainer, lf); lf->linkFlag = llirFactory->createLnkFlag(OctaveFactory::LNK2); $$ = lf; }
        | LNK3_TOKEN { NEW(OptionalLnkFlagContainer, lf); lf->linkFlag = llirFactory->createLnkFlag(OctaveFactory::LNK3); $$ = lf; }
        ;

newline: NEWLINE_TOKEN {  }
        | MACRO_LINE_DELIMITER_TOKEN { macro_line_delimiter_seen = 1; }
        ;

imm3:      expression  { $$ = $1; };
imm6:      expression  { $$ = $1; };
imm9:      expression  { $$ = $1; };
imm10:     expression  { $$ = $1; };
/*  lmm_imm8:  constant_expression  { $$ = $1; } */
lmm_imm8:  expression  { $$ = $1; };
lmm_imm14:  expression { $$ = $1; };
sft_imm5:  expression  { $$ = $1; };

bytesel0:  expression  { $$ = $1; };
bytesel1:  expression  { $$ = $1; };
bytesel2:  expression  { $$ = $1; };
bytesel3:  expression  { $$ = $1; };

bitop_small_int:  constant_expression {};
bitop_numbits:  constant_expression {};
bitop_bitpos:   constant_expression {};

byte_token: BYTE_TOKEN
            {
	      g_currentByteDirective = llirFactory->createByteDirective(get_node_line(), 
									get_src_line(),
									get_src_file());
	      g_currentBlock->addLlirNode(g_currentBlock, g_currentByteDirective);
	    }
            ;

byte_list : byte_datum
          | byte_list COMMA_TOKEN byte_datum
          ;

byte_datum: expression 
            {
	      g_currentByteDirective->addDatum(llirFactory->createDatum($1->exprPtr));
	    }
          | expression '[' expression ']'
            {
	      g_currentByteDirective->addDatum(llirFactory->createDatum($1->exprPtr, container_to_uimm_ptr($3)->getValue()));
	    }
          | LO16_RELOC_TOKEN '(' expression ')'
            {
	      g_currentByteDirective->addDatum(llirFactory->createDatum(llirFactory->createLo16Expr($3->exprPtr)));
	    }
          | HI16_RELOC_TOKEN '(' expression ')'
            {
	      g_currentByteDirective->addDatum(llirFactory->createDatum(llirFactory->createHi16Expr($3->exprPtr)));
	    }
          | WORD_ALIGN_TOKEN '(' expression ')'
            {
	      g_currentByteDirective->addDatum(llirFactory->createDatum(llirFactory->createWordExpr($3->exprPtr)));
	    }
          | LO16_RELOC_TOKEN '(' expression ')' '[' expression ']'
            {
	      g_currentByteDirective->addDatum(llirFactory->createDatum(llirFactory->createLo16Expr($3->exprPtr),
										container_to_uimm_ptr($6)->getValue()));
	    }
          | HI16_RELOC_TOKEN '(' expression ')' '[' expression ']'
            {
	      g_currentByteDirective->addDatum(llirFactory->createDatum(llirFactory->createHi16Expr($3->exprPtr),
									container_to_uimm_ptr($6)->getValue()));
	    }
          | WORD_ALIGN_TOKEN '(' expression ')' '[' expression ']'
            {
	      g_currentByteDirective->addDatum(llirFactory->createDatum(llirFactory->createWordExpr($3->exprPtr),
									container_to_uimm_ptr($6)->getValue()));
	    }
          ;

halfword_token: HALFWORD_TOKEN
            {
	      g_currentHalfWordDirective = llirFactory->createHalfWordDirective(get_node_line(), 
										    get_src_line(),
										    get_src_file());
	      g_currentBlock->addLlirNode(g_currentBlock, g_currentHalfWordDirective);
	    }
            ;

halfword_list : halfword_datum
          | halfword_list COMMA_TOKEN halfword_datum
          ;

halfword_datum: expression
                {
		  g_currentHalfWordDirective->addDatum(llirFactory->createDatum($1->exprPtr));
		}
              | expression '[' expression ']'
                {
		  g_currentHalfWordDirective->addDatum(llirFactory->createDatum($1->exprPtr, container_to_uimm_ptr($3)->getValue()));
		}
              | LO16_RELOC_TOKEN '(' expression ')'
                {
		  g_currentHalfWordDirective->addDatum(llirFactory->createDatum(llirFactory->createLo16Expr($3->exprPtr)));
		}
              | HI16_RELOC_TOKEN '(' expression ')'
                {
		  g_currentHalfWordDirective->addDatum(llirFactory->createDatum(llirFactory->createHi16Expr($3->exprPtr)));
		}
              | WORD_ALIGN_TOKEN '(' expression ')'
                {
		  g_currentHalfWordDirective->addDatum(llirFactory->createDatum(llirFactory->createWordExpr($3->exprPtr)));
		}
              | LO16_RELOC_TOKEN '(' expression ')' '[' expression ']'
                {
		  g_currentHalfWordDirective->addDatum(llirFactory->createDatum(llirFactory->createLo16Expr($3->exprPtr),
										container_to_uimm_ptr($6)->getValue()));
		}
              | HI16_RELOC_TOKEN '(' expression ')' '[' expression ']'
                {
		  g_currentHalfWordDirective->addDatum(llirFactory->createDatum(llirFactory->createHi16Expr($3->exprPtr),
										container_to_uimm_ptr($6)->getValue()));
		}
              | WORD_ALIGN_TOKEN '(' expression ')' '[' expression ']'
                {
		  g_currentHalfWordDirective->addDatum(llirFactory->createDatum(llirFactory->createWordExpr($3->exprPtr),
										container_to_uimm_ptr($6)->getValue()));
		}
              ;

word_token: WORD_TOKEN
            {
	      g_currentWordDirective = llirFactory->createWordDirective(get_node_line(), 
										    get_src_line(),
										    get_src_file());
	      g_currentBlock->addLlirNode(g_currentBlock, g_currentWordDirective);
	    }
          ;

word_list : word_datum
          | word_list COMMA_TOKEN word_datum
          ;

word_datum:  expression
             {
	       g_currentWordDirective->addDatum(llirFactory->createDatum($1->exprPtr));
	     }
          | expression '[' expression ']'
            {
	      g_currentWordDirective->addDatum(llirFactory->createDatum($1->exprPtr, container_to_uimm_ptr($3)->getValue()));
	    }
          | LO16_RELOC_TOKEN '(' expression ')'
            {
	      g_currentWordDirective->addDatum(llirFactory->createDatum(llirFactory->createLo16Expr($3->exprPtr)));
	    }
          | HI16_RELOC_TOKEN '(' expression ')'
            {
	      g_currentWordDirective->addDatum(llirFactory->createDatum(llirFactory->createHi16Expr($3->exprPtr)));
	    }
          | WORD_ALIGN_TOKEN '(' expression ')'
            {
	      g_currentWordDirective->addDatum(llirFactory->createDatum(llirFactory->createWordExpr($3->exprPtr)));
	    }
          | LO16_RELOC_TOKEN '(' expression ')' '[' expression ']'
            {
	      g_currentWordDirective->addDatum(llirFactory->createDatum(llirFactory->createLo16Expr($3->exprPtr),
									container_to_uimm_ptr($6)->getValue()));
	    }
          | HI16_RELOC_TOKEN '(' expression ')' '[' expression ']'
            {
	      g_currentWordDirective->addDatum(llirFactory->createDatum(llirFactory->createHi16Expr($3->exprPtr),
									container_to_uimm_ptr($6)->getValue()));
	    }
          | WORD_ALIGN_TOKEN '(' expression ')' '[' expression ']'
            {
	      g_currentWordDirective->addDatum(llirFactory->createDatum(llirFactory->createWordExpr($3->exprPtr),
									container_to_uimm_ptr($6)->getValue()));
	    }
          ;
 
limd_imm17: expression 
            { $$ = $1;}
          | LO17_RELOC_TOKEN '(' expression ')'
            {
	      NEW(ExpContainer, p);
	      p->exprPtr = llirFactory->createLo17Expr($3->exprPtr);
	      $$ = p;
	    }
          | LO16_RELOC_TOKEN '(' expression ')'
            {
	      NEW(ExpContainer, p);
	      p->exprPtr = llirFactory->createLo16Expr($3->exprPtr);
	      $$ = p;
	    }
          | HI16_RELOC_TOKEN  '(' expression ')'
            {
	      NEW(ExpContainer, p);
	      p->exprPtr = llirFactory->createHi16Expr($3->exprPtr);
	      $$ = p;
	    }
          ;

limd_imm16: expression 
            { $$ = $1; }
          | LO16_RELOC_TOKEN '(' expression ')' 
            {
	      NEW(ExpContainer, p);
	      p->exprPtr = llirFactory->createLo16Expr($3->exprPtr);
	      $$ = p;
	    }
          | HI16_RELOC_TOKEN  '(' expression ')'
            {
	      NEW(ExpContainer, p);
	      p->exprPtr = llirFactory->createHi16Expr($3->exprPtr);
	      $$ = p;
	    }
          ;

param_offset: constant_expression 
              { $$ = $1; };

pos_offset: constant_expression
              { $$ = $1; };

pipe_depth: constant_expression
              { $$ = $1; };

optional_pipe_depth: /* empty */ { 
             NEW(OptionalPipeDepthContainer, p);
	     p->pipe_depth = llirFactory->createNullOperand();
	     $$ = p;
	   }
         | pipe_depth { 
             NEW(OptionalPipeDepthContainer, p);
	     p->pipe_depth = $1->exprPtr;
	     $$ = p;
	   }
         ;

base_reg: BASE2_TOKEN { $$ = 2;}
        | BASE3_TOKEN { $$ = 3;}
        ;

traffic_sched_flags: /* empty */ { 
                     NEW(TrafficSchedFlagsContainer, p);
		     p->flags = llirFactory->createTrafficScheduleFlags();
                     current_traffic_sched_flags = p;
                     $$ = p;
                   }
                   | traffic_sched_flags traffic_sched_flag {
                     assert($1 == current_traffic_sched_flags);
		     $$ = $1;
                   }
                   ;

traffic_sched_flag: GC1A_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GC1A))); }
		  | GC1O_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GC1O))); }
		  | GC1B_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GC1B))); }
		  | GSTICK_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GSTICK))); }
		  | NUL_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::NUL))); }
		  | GC2A_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GC2A))); }
		  | GC2B_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GC2B))); }
		  | GC2O_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GC2O))); }
		  | GPA_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GPA))); }
		  | GPU_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GPU))); }
		  | GPB_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GPB))); }
		  | GTA_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GTA))); }
		  | GTO_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GTO))); }
		  | GTB_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GTB))); }
		  | FP_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::FP))); }
		  | NG2_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::NG2))); }
		  | GZ_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GZ))); }
		  | NB_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::NB))); }
		  | NC_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::NC))); }
		  | GW_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GW))); }
		  | GR_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GR))); }
		  | A_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::A))); }
		  | R_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::R))); }
		  | GU_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::GU))); }
		  | T_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::T))); }
		  | RB_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::RB))); }
		  | FB_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::FB))); }
		  | NT_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::NT))); }
                  | S_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::S))); }
                  | RSCH_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::RSCH))); }
                  | I_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::I))); }
                  | FR_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::FR))); }
                  | CLOSE_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::CLOSE))); }
                  | NE_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::NE))); }
                  | OAM_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::OAM))); }
                  | RP_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::RP))); }
                  | LOG_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::LOG))); }
		  | FPB_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::FPB))); }
		  | CSB_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::CSB))); }
		  | DELETE_TOKEN { current_traffic_sched_flags->flags->addFlag((llirFactory->createTssFlag(OctaveFactory::DELETE))); }
                  ;

/* with or without '.' */
type_or_map_string:  STRUCTURE_REFERENCE_TOKEN 
                  {
		     $$ = $1; 
                  }
                  |  IDENTIFIER_TOKEN
                  {
                     $$ = $1
                  }
                  ;

assert_rule: ASSERT_TOKEN '(' expression COMMA_TOKEN  expression ')'
                  {
		    $$ = container_to_uimm_ptr(assert_op($3, $5))->getValue();
		  }
                  ;

sizeof: SIZEOF_TOKEN '(' sizeof_reg_spec   ')' 
                  {
		    $$ = $3->regPtr->getNumRegs() * 4;
                  }
                  ;

offsetof: OFFSETOF_TOKEN '(' type_or_map_string  ')'   
                 {
		   $$ = getOffset($3);
                 }
                 ;

relative_offsetof: OFFSETOF_TOKEN '(' type_or_map_string  COMMA_TOKEN type_or_map_string ')'   
                 {
		   unsigned int offset = getRelativeOffset($3, $5);
		   $$ = offset;
                 }
                 ;

lsbof: LSBOF_TOKEN '(' type_or_map_string  ')'   
                 {
		   $$ = getLsbOf($3);
                 }
                 ;

msbof: MSBOF_TOKEN '(' type_or_map_string  ')'   
                 {
		   $$ = getMsbOf($3);
                 }
                 ;

bitpos: BITPOS_TOKEN '(' type_or_map_string  ')'   
                 {
		   $$ = getBitPos($3);
                 }
                 ;

nrbits: NRBITS_TOKEN '(' type_or_map_string  ')'   
                 {
		   $$ = getNumBits($3);
                 }
                 ;

baseof: BASEOF_TOKEN '(' reg_spec ')' 
                 {
		   //pass back a Register...
		   if ($3->baseregSet)
		     {
		       NEW(RegContainer, rc);
		       rc->regPtr = $3->baseregPtr;
		       $$ = rc;
		     }
		   else
		     {
		       $$ = clone_reg_as_single_with_offset($3, 0);
		     }
                 }
                 ;

regof: REGOF_TOKEN '(' reg_spec ')' 
                 {
		   //pass back a Register...
		   NEW(RegContainer, crc);
		   crc->regPtr = $3->regPtr->getRegister(0);
		   $$ = crc;
                 }
                 ;

regnum: REGNUM_TOKEN '(' reg_spec ')'
                 {
		   $$ = $3->regPtr->getRegister(0)->getRegNum();
		 }
                 ;


position: POS_TOKEN '(' CONSTANT_TOKEN ')'    
                {
		  $$ = bit_position($3);
                }
                ;

label_name: IDENTIFIER_TOKEN {};

/* Label definition (not use). */
label: label_name ':'     
     { 
        add_label_symbol($1, OctaveSymbol::LOCAL); 
     }
     | label_name ':' '=' 
     { 
        add_label_symbol($1, OctaveSymbol::FILESCOPE); 
     }
     | label_name ':' ':' 
     {
        add_label_symbol($1, OctaveSymbol::GLOBAL);
     }
     | label_name error newline  {  
         /* Reported as parse error. */
     }
     ;

align_val: CONSTANT_TOKEN        { $$ = $1;}
         | WORD_ALIGN_TOKEN      { $$ = 4;}
         | HALFWORD_ALIGN_TOKEN  { $$ = 2;}
         | BYTE_ALIGN_TOKEN      { $$ = 1;}
         ;

/* Providing a level of indirection here collapses a bunch of identical
   shift/reduce conflicts into just one. */
expression: expr { $$ = $1; };

expr: CONSTANT_TOKEN    { $$ = unsigned_immed_container($1); }
    | IDENTIFIER_TOKEN  { $$ = label_container($1); }
    | dot_expr          { $$ = label_container($1); }
    | assert_rule       { $$ = unsigned_immed_container($1); }
    | sizeof            { $$ = unsigned_immed_container($1); }
    | offsetof          { $$ = unsigned_immed_container($1); }
    | relative_offsetof { $$ = unsigned_immed_container($1); }
    | lsbof             { $$ = unsigned_immed_container($1); }
    | msbof             { $$ = unsigned_immed_container($1); }
    | bitpos            { $$ = unsigned_immed_container($1); }
    | nrbits            { $$ = unsigned_immed_container($1); }
    | regnum            { $$ = unsigned_immed_container($1); }
    | position          { $$ = unsigned_immed_container($1); }
    | '(' expr ')'      { $$ = parens_eval($2); }
    | expr '+' expr     { $$ = add_op($1, $3); }
    | expr '-' expr     { $$ = subtract_op($1, $3); }
    | expr '*' expr     { $$ = multiply_op($1, $3); }
    | expr '/' expr     { $$ = divide_op($1, $3); }
    | expr '%' expr     { $$ = modulo_op($1, $3); }
    | expr '|' expr     { $$ = or_op($1, $3); }
    | expr '&' expr     { $$ = and_op($1, $3); }
    | expr '^' expr     { $$ = xor_op($1, $3); }
    | expr LEFT_SHIFT_TOKEN expr   { $$ = leftshift_op($1, $3); }
    | expr RIGHT_SHIFT_TOKEN expr  { $$ = rightshift_op($1, $3); }
    | '-' expr %prec UMINUS  { $$ = negate_op($2); }
    | '~' expr %prec ONES_COMPLEMENT  { $$ = ones_complement_op($2); }
    ;

constant_expression: CONSTANT_TOKEN    { $$ = unsigned_immed_container($1); }
    | assert_rule       { $$ = unsigned_immed_container($1); }
    | sizeof            { $$ = unsigned_immed_container($1); }
    | offsetof          { $$ = unsigned_immed_container($1); }
    | relative_offsetof { $$ = unsigned_immed_container($1); }
    | lsbof             { $$ = unsigned_immed_container($1); }
    | msbof             { $$ = unsigned_immed_container($1); }
    | bitpos            { $$ = unsigned_immed_container($1); }
    | nrbits            { $$ = unsigned_immed_container($1); }
    | regnum            { $$ = unsigned_immed_container($1); }
    | position          { $$ = unsigned_immed_container($1); }
    | '(' constant_expression ')'      { $$ = parens_eval($2); }
    | constant_expression '+' constant_expression     { $$ = add_op($1, $3); }
    | constant_expression '-' constant_expression     { $$ = subtract_op($1, $3); }
    | constant_expression '*' constant_expression     { $$ = multiply_op($1, $3); }
    | constant_expression '/' constant_expression     { $$ = divide_op($1, $3); }
    | constant_expression '%' constant_expression     { $$ = modulo_op($1, $3); }
    | constant_expression '|' constant_expression     { $$ = or_op($1, $3); }
    | constant_expression '&' constant_expression     { $$ = and_op($1, $3); }
    | constant_expression '^' constant_expression     { $$ = xor_op($1, $3); }
    | constant_expression ANDAND_TOKEN constant_expression       { $$ = andand_op($1, $3); }
    | constant_expression OROR_TOKEN constant_expression         { $$ = oror_op($1, $3); }
    | constant_expression GEQ_TOKEN constant_expression          { $$ = geq_op($1, $3); }
    | constant_expression LEQ_TOKEN constant_expression          { $$ = leq_op($1, $3); }
    | constant_expression '>' constant_expression                { $$ = gt_op($1, $3); }
    | constant_expression '<' constant_expression                { $$ = lt_op($1, $3); }
    | constant_expression EQ_TOKEN constant_expression           { $$ = eq_op($1, $3); }
    | constant_expression NEQ_TOKEN constant_expression          { $$ = neq_op($1, $3); }
    | constant_expression LEFT_SHIFT_TOKEN constant_expression   { $$ = leftshift_op($1, $3); }
    | constant_expression RIGHT_SHIFT_TOKEN constant_expression  { $$ = rightshift_op($1, $3); }
    | '-' constant_expression %prec UMINUS  { $$ = negate_op($2); }
    | '~' constant_expression %prec ONES_COMPLEMENT  { $$ = ones_complement_op($2); }
    ;

brsl_arg_set: /* empty */ {
                 NEW(BrslArgsContainer, p);
		 current_brsl_arg_set = p;
		 $$ = p;
		 }
                | brsl_arg_set brsl_arg {
                 assert($1 == current_brsl_arg_set);
		 $$ = $1;
		}
             ;

brsl_arg: UL_TOKEN  {
	   if (current_brsl_arg_set->ul) {
	     parseAlo->logException(shared_ptr<DuplicateOperand>(new DuplicateOperand("UL already set",
									  get_src_line(), 
									  get_src_file(), 
									  __LINE__, __FILE__)));
	   }
	   else {
	     current_brsl_arg_set->ul = 1;
	   }
         }
         | DLNK_TOKEN {
           if (current_brsl_arg_set->dlnk) {
	     parseAlo->logException(shared_ptr<DuplicateOperand>(new DuplicateOperand("DLNK already set",
										      get_src_line(), 
										      get_src_file(), 
										      __LINE__, __FILE__)));
           }
           else {
             current_brsl_arg_set->dlnk = 1;
	   }
	 }
         | FL_TOKEN {
           if (current_brsl_arg_set->fl) {
	     parseAlo->logException(shared_ptr<DuplicateOperand>(new DuplicateOperand("FL already set",
										      get_src_line(), 
										      get_src_file(), 
										      __LINE__, __FILE__)));
           }
           else {
             current_brsl_arg_set->fl = 1;
	   }
	 }
         | PR_TOKEN  {
           if (current_brsl_arg_set->pr) {
	     parseAlo->logException(shared_ptr<DuplicateOperand>(new DuplicateOperand("PR already set",
										      get_src_line(), 
										      get_src_file(), 
										      __LINE__, __FILE__)));
           }
           else {
             current_brsl_arg_set->pr = 1;
           }
	 }
         ;

cond_branch_args: /* empty */  { 
                  NEW (CondBranchFlagsContainer, p); 
		  current_cond_branch_flags = p;
                  $$ = p;
                }
                | cond_branch_args cond_branch_arg {
                  assert($1 == current_cond_branch_flags);
		  $$ = $1;
                }
                ;

ess: ess_flag {
     NEW(EssContainer, p);
     p->ess = llirFactory->createEssFlag((OctaveFactory::Ess)$1, false);
     $$ = p;
   }
   | NOT_TOKEN ess_flag {
     NEW(EssContainer, p);
     p->ess = llirFactory->createEssFlag($2, true);
     $$ = p;
   }
   ;

cond_branch_arg: ess { 
		 if (current_cond_branch_flags->ess) {
		     parseAlo->logException(shared_ptr<DuplicateOperand>(new DuplicateOperand("ess already set",
											      get_src_line(), 
											      get_src_file(), 
											      __LINE__, __FILE__)));
		   }
		 else {
		     current_cond_branch_flags->ess = $1->ess;
		   }
	       }
               | C_BIT_TOKEN         {
		 if (current_cond_branch_flags->c_bit) {
		     parseAlo->logException(shared_ptr<DuplicateOperand>(new DuplicateOperand("C bit already set",
											      get_src_line(), 
											      get_src_file(), 
											      __LINE__, __FILE__)));
		   }
		 else {
		     current_cond_branch_flags->c_bit = 1;
		   }
	       }
               | BF_TOKEN            {
		 if (current_cond_branch_flags->bf_bit) {
		     parseAlo->logException(shared_ptr<DuplicateOperand>(new DuplicateOperand("BF bit already set",
											      get_src_line(), 
											      get_src_file(), 
											      __LINE__, __FILE__)));
		 }
		 else {
		     current_cond_branch_flags->bf_bit = 1;
		 }
	       }
               | REGISTER_TOKEN  {
		 if (current_cond_branch_flags->rd) {
		     parseAlo->logException(shared_ptr<DuplicateOperand>(new DuplicateOperand("RD reg already set",
											      get_src_line(), 
											      get_src_file(), 
											      __LINE__, __FILE__)));
		   }
		 else {
		     current_cond_branch_flags->rd = llirFactory->createHardReg($1); 
		 }
	       }
               ;
	   

bi_arg_set: /* EMPTY */ {
	 NEW (ImmedBranchArgsContainer, p); 
	 p->rd = llirFactory->createNullOperand();
	 p->cd_flag = llirFactory->createNullOperand();
	 $$ = p;
       }
       | REGISTER_TOKEN {
	 NEW (ImmedBranchArgsContainer, p);
	 p->rd =  llirFactory->createHardReg($1);
	 p->cd_flag = llirFactory->createNullOperand();
	 $$ = p;
       }
       | CD_TOKEN {
	 NEW (ImmedBranchArgsContainer, p);
	 p->rd = llirFactory->createNullOperand();
	 p->cd_flag = llirFactory->createCDFlag();
	 $$ = p;
       }
       | REGISTER_TOKEN CD_TOKEN {
	 NEW (ImmedBranchArgsContainer, p);
	 p->rd = llirFactory->createHardReg($1);
	 p->cd_flag = llirFactory->createCDFlag();
	 $$ = p;
       }
       | CD_TOKEN REGISTER_TOKEN {
	 NEW (ImmedBranchArgsContainer, p);
	 p->rd = llirFactory->createHardReg($2);
	 p->cd_flag = llirFactory->createCDFlag();
	 $$ = p;
       }
       ;
 

defmacro_args: IDENTIFIER_TOKEN '(' defmacro_arg_list ')' 
            {
              defmacro_identifier($1);
            lex_enter_defmacro_body();
            }
            ;

defmacro_arg_list: /* empty */ { defmacro_begin(); }
       | IDENTIFIER_TOKEN 
           { 
             defmacro_begin();
             defmacro_add_param($1); 
         }
       | defmacro_arg_list COMMA_TOKEN IDENTIFIER_TOKEN { defmacro_add_param($3); }
       ;


%%
/* Supporting C code. */

extern FILE *alo_in;
static FILE *alo_in_save;
extern char *alo_text;
extern int alo_lineno;

void yyerror(const char *msg)
{
  ostringstream excStr;
  excStr << " " << msg << "\n";

  string text = buffered_tokens_to_string();
  excStr << text.c_str();

  parseAlo->logException(shared_ptr<ParseError>(new ParseError(excStr.str().c_str(),
							       get_src_line(), 
							       get_src_file(), 
							       __LINE__, __FILE__)));
}

/* 
   exceptions that cannot be logged 
   since, normal parsing cannot continue
   in such cases.
*/
   
void fatal_error(const char *msg)
{
  std::cerr << msg << "\n";
  exit(1);
}

/* Provide access to C++-compiled yyparse() from C code. */
int yyparse_cpp()
{
  return yyparse();
}

void parse_main(const char *ifile, OctaveAlo &alo, shared_ptr<LlirFile> file)
{
  int parse_result;

  parseAlo = &alo;
  llirFactory = parseAlo->getFactory();

  g_currentFile = file;
  g_rootBlock = llirFactory->createGlobalBlock();

  parse_begin_hook();

  file->addLlirNode(g_rootBlock);
  g_currentBlock = g_rootBlock;

  // Clear nesting stack, then push NONE_BLOCK.
  while (!nesting_stack.empty())
    {
      nesting_stack.pop();
    }
  nesting_stack.push(NONE_BLOCK);

  //global variable alo_lineno must
  //be reset in case we are parsing
  //multiple files on the command line...
  alo_lineno = 1;			

  alo_in = fopen(ifile, "r");
  alo_in_save = alo_in;
  if (alo_in == NULL)
    {
      throw InvalidFileName("Could not open input file.", __LINE__, __FILE__);
    }

  parse_result = yyparse();
  
  if (parse_result != 0)
    {
      /* We will get here if there was a syntax error that was not
       * handled with an "error" rule.  Not sure if we should do
       * anything, but in any case do NOT restart the parse like the
       * while loop in an earlier version of this code used to do. */
      parseAlo->logException(shared_ptr<ParseError>(new ParseError("syntax error",
								   get_src_line(), 
								   get_src_file(), 
								   __LINE__, 
								   __FILE__)));

      return;
    }

  parse_done_hook();

  /* Note, we cannot just close "alo_in" here because the top of the
   * lexer input stack might be a string, and alo_in is NULL while
   * parsing strings. */
  fclose(alo_in_save);
}


/* End-of-compilation-unit cleanup and checks. */
static void source_file_completion()
{
  conditional_check_finished();
  if (g_currentBlock->getParent() != g_currentBlock->parentListEnd())
    {
      parseAlo->logException(shared_ptr<ParseError>(new ParseError("stray .block in file (no matching .endblock)",
								   get_src_line(), 
								   get_src_file(), 
								   __LINE__, 
								   __FILE__))); 
    }

  if (alo_debug)
    {
      defmacro_report();
    }
}


/* Debug printf, only prints (to stderr) if alo_debug is set via --yydebug . */
void d_printf(const char *fmt, ...)
{
  va_list ap;
  if (alo_debug)
    {
      fprintf(stderr, "parser: ");
      va_start(ap, fmt);
      vfprintf(stderr, fmt, ap);
      va_end(ap);  
    }
}

/* Use this instead of calling fooStruct->addType() directly.  This lets us
   implement the try/catch just once. */
static void structure_add_type(shared_ptr<Struct> s, shared_ptr<Type> t)
{
  try
    {
      s->addType(t);
    }
  catch (LlirTypeException lte) 
    {
      parseAlo->logException(shared_ptr<ParseError>(new ParseError(lte.what(),
								   get_src_line(),
								   get_src_file(), 
								   lte.getLineNum(),
								   lte.getFileName().c_str())));
    }
}

/* Use this instead of calling fooElement->addType() directly. */
static void element_add_type(shared_ptr<Element> e, shared_ptr<Type> t)
{
  try
    {
      e->addType(t);
    }
  catch (LlirTypeException lte)
    {
      parseAlo->logException(shared_ptr<ParseError>(new ParseError(lte.what(),
								   get_src_line(),
								   get_src_file(), 
								   lte.getLineNum(),
								   lte.getFileName().c_str())));
    }
}


static void do_mapping(TypeContainer *tc, const char *mapname, shared_ptr<const Register> reg)
{
  shared_ptr<const Struct> st;
  shared_ptr<MapSymbol> sym;
  shared_ptr<MapDirective> md;
  shared_ptr<const HardRegister> hr;
  shared_ptr<const PseudoRegister> pr;
  shared_ptr<const MultiHardRegister> mhr;
  shared_ptr<const MultiPseudoRegister> mpr;
  unsigned int size;

  /* Downcast "ty" to a struct, downcast all four cases for "reg" and
     call appropriate methods on factory, then call (global) AddRegSymbol() */

  d_printf("mapping type %s to instance %s\n", tc->ty->getName().c_str(), mapname);
  
  if (!(st = shared_dynamic_cast<const Struct>(tc->ty)))
    {
      string s = tc->name;
      s = s + " is not a structure, cannot map to it";
      parseAlo->logException(shared_ptr<IllegalSymbolOperand>(new IllegalSymbolOperand(s.c_str(),
										       get_src_line(), 
										       get_src_file(), 
										       __LINE__, __FILE__)));
      return;
    }

  size = st->getSize();

  if ((hr = shared_dynamic_cast<const HardRegister>(reg)))
    {
      /* "Promote" to multi-reg if size of type is > singlereg. */
      if (st->getSize() >= 4)
	{
	  mhr = llirFactory->createMultiHardReg(st->getSize()/4, reg->getRegNum());
	  sym = llirFactory->createMapToMultiHardReg(mapname, OctaveSymbol::GLOBAL, st, mhr);
	}
      else
	{
	  sym = llirFactory->createMapToHardReg(mapname, OctaveSymbol::GLOBAL, st, hr);
	}
    }
  else if ((pr = shared_dynamic_cast<const PseudoRegister>(reg)))
    {
      /* "Promote" to multi-reg if size of type is > singlereg. */
      if (st->getSize() >= 4)
	{
	  mpr = llirFactory->createMultiPseudoReg(st->getSize()/4, reg->getRegNum(), (pr->getRegName()).c_str());
	  sym = llirFactory->createMapToMultiPseudoReg(mapname, OctaveSymbol::GLOBAL, st, mpr); 
	}
      else
	{
	  sym = llirFactory->createMapToPseudoReg(mapname, OctaveSymbol::GLOBAL, st, pr); 
	}
    }
  else if ((mhr = shared_dynamic_cast<const MultiHardRegister>(reg)))
    {

      if ((st->getSize()/4) == reg->getNumRegs())
	{
	  mhr = llirFactory->createMultiHardReg(st->getSize()/4, reg->getRegNum());
	  sym = llirFactory->createMapToMultiHardReg(mapname, OctaveSymbol::GLOBAL, st, mhr);
	}
      else
	{
	  string s = string("Size of type: ") + string("\"") + tc->name + 
	    string("\"") + string(" does not match register specification");
	  parseAlo->logException(shared_ptr<IllegalMappingOperand>(new IllegalMappingOperand(s.c_str(),
											     get_src_line(), 
											     get_src_file(), 
											     __LINE__, __FILE__)));
	  return;
	}

    }
  else if ((mpr = shared_dynamic_cast<const MultiPseudoRegister>(reg)))
    {


      if ((st->getSize()/4) == reg->getNumRegs())
	{
	  mpr = llirFactory->createMultiPseudoReg(st->getSize()/4, reg->getRegNum(), (mpr->getRegName()).c_str());
	  sym = llirFactory->createMapToMultiPseudoReg(mapname, OctaveSymbol::GLOBAL, st, mpr);
	}
      else
	{
	  string s = string("Size of type: ") + string("\"") + tc->name + 
	    string("\"") + string(" does not match register specification");
	  parseAlo->logException(shared_ptr<IllegalMappingOperand>(new IllegalMappingOperand(s.c_str(),
											     get_src_line(), 
											     get_src_file(), 
											     __LINE__, __FILE__)));
	  return;
	}
    }
  else if ((shared_dynamic_cast<const NullRegister>(reg)))
    {
      // looks like some error in the input program and
      // the register_spec did not get evaluated to a valid
      // hard/pseudo register...

      // create a dummy map name...
      // do not log an error... as it would have already been logged.

      hr = llirFactory->createHardReg(0);
      sym = llirFactory->createMapToHardReg(mapname, OctaveSymbol::GLOBAL, st, hr);
    }

  AddOctaveSymbol(sym);

  md = llirFactory->createMapDirective(get_node_line(), 
				       get_src_line(),
				       get_src_file(), tc->name.c_str(), mapname, sym);
  g_currentBlock->addLlirNode(g_currentBlock, md);
}


static void undo_mapping(const char *name)
{
  UnMapSymbol(name);
  g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createUnmapDirective(get_node_line(), 
										get_src_line(),
										get_src_file(), name));
}


static void create_block()
{
  shared_ptr<LlirOctaveBlock> b;

  b = llirFactory->createBlock(get_node_line(), 
			       get_src_line(),
			       get_src_file());

  g_currentBlock->addLlirNode(g_currentBlock, b);
  g_currentBlock = b;

  nesting_stack.push(BLOCK_BLOCK);
}

static void create_block(const char *name)
{
  shared_ptr<LlirOctaveBlock> b;

  if (AddOctaveSymbol(llirFactory->createBlockSymbol(name)))
    b = llirFactory->createBlock(name, get_node_line(), 
				 get_src_line(),
				 get_src_file());
  else
    {
      // In the error case create a block with no name
      b = llirFactory->createBlock(get_node_line(), 
				   get_src_line(),
				   get_src_file());
    }
  
  g_currentBlock->addLlirNode(g_currentBlock, b);
  g_currentBlock = b;

  nesting_stack.push(BLOCK_BLOCK);
}



static void create_macro_block()
{
  shared_ptr<LlirOctaveBlock> b;
  b = llirFactory->createMacroBlock(get_node_line(), 
				    get_src_line(),
				    get_src_file());

  g_currentBlock->addLlirNode(g_currentBlock, b);
  g_currentBlock = b;
}


static void end_block()
{
  if (nesting_stack.top() != BLOCK_BLOCK)
    {
      string s = "nesting error at .endblock, opening directive was ";
      s.append(block_thing_names[nesting_stack.top()]);
      parseAlo->logException(shared_ptr<ParseError>(new ParseError(s.c_str(),
								   get_src_line(), 
								   get_src_file(), 
								   __LINE__, 
								   __FILE__)));
    }
  else
    {
      nesting_stack.pop();
    }

  shared_ptr<EndBlock> ebd;
  LlirOctaveBlock::ParentListIterator pli;
  pli = g_currentBlock->getParent();
  if (pli == g_currentBlock->parentListEnd()) /* This is how we check for "NULL" in C++. */
    {
      parseAlo->logException(shared_ptr<ParseError>(new ParseError("stray .endblock (no matching .block)",
								   get_src_line(), 
								   get_src_file(), 
								   __LINE__, __FILE__)));
      return;
    }

#ifdef OPTIMIZING_ALO
  do_end_smap (g_currentBlock);
#endif
  g_currentBlock = pli->second;  /* iterator points to an object like {first=key,second=data} */
  ebd = llirFactory->createEndBlockDirective(get_node_line(), 
					     get_src_line(),
					     get_src_file());
  g_currentBlock->addLlirNode(g_currentBlock, ebd);
}

static void end_block(const char *name)
{
  if (nesting_stack.top() != BLOCK_BLOCK)
    {
      string s = "nesting error at .endblock, opening directive was ";
      s.append(block_thing_names[nesting_stack.top()]);
      parseAlo->logException(shared_ptr<ParseError>(new ParseError(s.c_str(),
								   get_src_line(), 
								   get_src_file(), 
								   __LINE__, 
								   __FILE__)));
    }
  else
    {
      nesting_stack.pop();
    }

  shared_ptr<EndBlock> ebd;
  LlirOctaveBlock::ParentListIterator pli;

  if (g_currentBlock->getName() != string(name))
    {
      string s = string(".endblock with name: ") + string("\"") + string(name) + 
	string("\"") + string(" does not match .block with name: " + string("\"") + g_currentBlock->getName() + string("\""));
      parseAlo->logException(shared_ptr<IllegalSymbolOperand>(new IllegalSymbolOperand(s.c_str(),
										       get_src_line(), 
										       get_src_file(), 
										       __LINE__, __FILE__)));

    }

  pli = g_currentBlock->getParent();
  if (pli == g_currentBlock->parentListEnd()) /* This is how we check for "NULL" in C++. */
    {
      parseAlo->logException(shared_ptr<ParseError>(new ParseError("stray .endblock (no matching .block)",
								   get_src_line(), 
								   get_src_file(), 
								   __LINE__, __FILE__)));
      return;
    }

#ifdef OPTIMIZING_ALO
  do_end_smap (g_currentBlock);
#endif
  g_currentBlock = pli->second;  /* iterator points to an object like {first=key,second=data} */
  ebd = llirFactory->createEndBlockDirective(get_node_line(), 
					     get_src_line(),
					     get_src_file(), name);
  g_currentBlock->addLlirNode(g_currentBlock, ebd);
}

static void end_macro_block()
{
  g_currentBlock->addLlirNode(g_currentBlock, llirFactory->createEndMacroDirective(get_node_line(), 
										   get_src_line(),
										   get_src_file()));

  LlirOctaveBlock::ParentListIterator pli;
  pli = g_currentBlock->getParent();
  if (pli == g_currentBlock->parentListEnd()) /* This is how we check for "NULL" in C++. */
    {
      parseAlo->logException(shared_ptr<ParseError>(new ParseError("stray .endblock (no matching .block)",
								   get_src_line(), 
								   get_src_file(), 
								   __LINE__, __FILE__)));
      return;
    }

#ifdef OPTIMIZING_ALO
  do_end_smap (g_currentBlock);
#endif
  g_currentBlock = pli->second;  /* iterator points to an object like {first=key,second=data} */
}



/* Some action code moved into functions. */
BitopArgsContainer *handle_depb_form_RBRBN(RegContainer *r1, ExpContainer *r1_bitpos,
					   RegContainer *r2, ExpContainer *r2_bitpos,
					   ExpContainer *numbits)
{
  NEW(BitopArgsContainer, ac);
  d_printf("bitop RBRBN\n");
  ac->src = r1->regPtr;
  ac->srcBitNum = container_to_uimm_ptr(r1_bitpos);
  ac->dst = r2->regPtr;
  ac->dstBitNum = container_to_uimm_ptr(r2_bitpos);
  ac->numBits = container_to_uimm_ptr(numbits);
  return ac;
}

BitopArgsContainer *handle_depb_form_RBFN(RegContainer *r1, ExpContainer *r1_bitpos,
					  RegContainer *field2,
					  ExpContainer *numbits)
{
  BitopArgsContainer *ac = handle_depb_form_RBF(r1, r1_bitpos, field2);
  d_printf(" `-bitop RBFN\n");
  if (ac->numBits->getValue() != container_to_uimm_ptr(numbits)->getValue())
    {
      parseAlo->logException(shared_ptr<IllegalBitopOperand>(new IllegalBitopOperand("4th operand (numbits) != #bits of 3rd (field) operand",
										     get_src_line(), 
										     get_src_file(), 
										     __LINE__, __FILE__)));
    }  
  return ac;
}


BitopArgsContainer *handle_depb_form_RBF(RegContainer *r1, ExpContainer *r1_bitpos,
					 RegContainer *field2)
{
  NEW(BitopArgsContainer, ac);
  d_printf("bitop RBF\n");
  ac->src = r1->regPtr;
  ac->srcBitNum = container_to_uimm_ptr(r1_bitpos);
  if (field2->isfield)
    {
      ac->dst = field2->regPtr;
      ac->dstBitNum = llirFactory->createUnsignedImmediate(field2->bitfield->getLSBitPosition());
      ac->numBits = llirFactory->createUnsignedImmediate(get_bitfield_size(field2->bitfield));
    }
  else
    {
      parseAlo->logException(shared_ptr<IllegalBitopOperand>(new IllegalBitopOperand("3rd argument must be a bitfield",
										     get_src_line(), 
										     get_src_file(), 
										     __LINE__, __FILE__)));
      ac->dst = field2->regPtr;
      ac->dstBitNum = llirFactory->createUnsignedImmediate(0);
      ac->numBits = llirFactory->createUnsignedImmediate(0);
    }
  return ac;
}

BitopArgsContainer *handle_depb_form_FRBN(RegContainer *field1,
					  RegContainer *r2, ExpContainer *r2_bitpos,
					  ExpContainer *numbits)
{
  BitopArgsContainer *ac = handle_depb_form_FRB(field1, r2, r2_bitpos);
  d_printf(" `-bitop FRBN\n");
  if (ac->numBits->getValue() != container_to_uimm_ptr(numbits)->getValue())
    {
      parseAlo->logException(shared_ptr<IllegalBitopOperand>(new IllegalBitopOperand("4th operand (numbits) != #bits of 1st (field) operand",
										     get_src_line(), 
										     get_src_file(), 
										     __LINE__, __FILE__)));
    }
  return ac;
}

BitopArgsContainer *handle_depb_form_FRB(RegContainer *field1,
					 RegContainer *r2, ExpContainer *r2_bitpos)
{
  d_printf("bitop FRB\n");
  NEW(BitopArgsContainer, ac);
  if (field1->isfield)
    {
      ac->src = field1->regPtr;
      ac->srcBitNum = llirFactory->createUnsignedImmediate(field1->bitfield->getLSBitPosition());
      ac->numBits = llirFactory->createUnsignedImmediate(get_bitfield_size(field1->bitfield));
    }
  else
    {
      parseAlo->logException(shared_ptr<IllegalBitopOperand>(new IllegalBitopOperand("1st argument must be a bitfield",
										     get_src_line(), 
										     get_src_file(), 
										     __LINE__, __FILE__)));
      ac->src = field1->regPtr;
      ac->srcBitNum = llirFactory->createUnsignedImmediate(0);
      ac->numBits = llirFactory->createUnsignedImmediate(0);
    }
  ac->dst = r2->regPtr;
  ac->dstBitNum = container_to_uimm_ptr(r2_bitpos);
  return ac;
}

BitopArgsContainer *handle_depb_form_FF(RegContainer *field1,
					RegContainer *field2)
{
  NEW(BitopArgsContainer, ac);
  unsigned long numbits1 = 0;
  unsigned long numbits2 = 0;

  d_printf("bitop FF\n");
  if (field1->isfield)
    {
      ac->src = field1->regPtr;
      ac->srcBitNum = llirFactory->createUnsignedImmediate(field1->bitfield->getLSBitPosition());
      numbits1 = get_bitfield_size(field1->bitfield);
    }
  else
    {
      parseAlo->logException(shared_ptr<IllegalBitopOperand>(new IllegalBitopOperand("1st argument must be a bitfield",
										     get_src_line(), 
										     get_src_file(), 
										     __LINE__, __FILE__)));
      ac->src = field1->regPtr;
      ac->srcBitNum = llirFactory->createUnsignedImmediate(0);
      numbits1 = 0;
    }

  if (field2->isfield)
    {
      ac->dst = field2->regPtr;
      ac->dstBitNum = llirFactory->createUnsignedImmediate(field2->bitfield->getLSBitPosition());
      numbits2 = get_bitfield_size(field2->bitfield);
    }
  else
    {
      parseAlo->logException(shared_ptr<IllegalBitopOperand>(new IllegalBitopOperand("2nd argument must be a bitfield",
										     get_src_line(), 
										     get_src_file(), 
										     __LINE__, __FILE__)));
      ac->dst = field2->regPtr;
      ac->dstBitNum = llirFactory->createUnsignedImmediate(0);
      numbits2 = 0;
    }
 
  if (numbits1 > numbits2)
    {
      char msg[32];                                     
      sprintf(msg, " %ld, %ld", numbits1, numbits2);
      string s = "source bitfield size is larger than target in bitfield structure";
      s += msg;			                 
      parseAlo->logException(shared_ptr<IllegalBitopOperand>(new IllegalBitopOperand(s.c_str(),
										     get_src_line(), 
										     get_src_file(), 
										     __LINE__, __FILE__)));
      
    }

  ac->numBits = llirFactory->createUnsignedImmediate(numbits1);
  return ac;
}


/* Most of the extb variants can be handled through the depb handlers. */
BitopArgsContainer *handle_extb_form_RBRBN(RegContainer *r1, ExpContainer *r1_bitpos,
					   RegContainer *r2, ExpContainer *r2_bitpos,
					   ExpContainer *numbits)
{
  return handle_depb_form_RBRBN(r1, r1_bitpos, r2, r2_bitpos, numbits);
}

BitopArgsContainer *handle_extb_form_RBFN(RegContainer *r1, ExpContainer *r1_bitpos,
					  RegContainer *field2,
					  ExpContainer *numbits)
{
  /* This one is slightly different than the depb version - numbits need not equal #bits of field2. */
  BitopArgsContainer *ac = handle_depb_form_RBF(r1, r1_bitpos, field2);
  ac->numBits = container_to_uimm_ptr(numbits);
  return ac;
}

BitopArgsContainer *handle_extb_form_FRBN(RegContainer *field1,
					  RegContainer *r2, ExpContainer *r2_bitpos,
					  ExpContainer *numbits)
{
  return handle_depb_form_FRBN(field1, r2, r2_bitpos, numbits);
}

BitopArgsContainer *handle_extb_form_FRB(RegContainer *field1,
					 RegContainer *r2, ExpContainer *r2_bitpos)
{
  return handle_depb_form_FRB(field1, r2, r2_bitpos);
}

BitopArgsContainer *handle_extb_form_FF(RegContainer *field1,
					RegContainer *field2)
{
  return handle_depb_form_FF(field1, field2);
}


DepbiArgsContainer *handle_depbi_form1(ExpContainer *immed, RegContainer *r, ExpContainer *bitpos, ExpContainer *numbits)
{
  NEW(DepbiArgsContainer, dac);
  dac->src = container_to_uimm_ptr(immed);
  dac->dst = r->regPtr;
  dac->dstBitNum = container_to_uimm_ptr(bitpos);
  dac->numBits = container_to_uimm_ptr(numbits);
  return dac;
}

DepbiArgsContainer *handle_depbi_form2(ExpContainer *immed, RegContainer *r)
{
  NEW(DepbiArgsContainer, dac);
  dac->src = container_to_uimm_ptr(immed);

  if (r->isfield)
    {
      dac->dst = r->regPtr;
      dac->dstBitNum = llirFactory->createUnsignedImmediate(r->bitfield->getLSBitPosition());
      dac->numBits = llirFactory->createUnsignedImmediate(get_bitfield_size((r->bitfield)));
    }
  else
    {
      parseAlo->logException(shared_ptr<IllegalBitopOperand>(new IllegalBitopOperand("argument must be a bitfield",
										     get_src_line(), 
										     get_src_file(), 
										     __LINE__, __FILE__)));
      dac->dst = r->regPtr;
      dac->dstBitNum = llirFactory->createUnsignedImmediate(0);
      dac->numBits = llirFactory->createUnsignedImmediate(0);
    }
  return dac;
}

TestArgsContainer *handle_test_form1(RegContainer *r, ExpContainer *bitnum)
{
  NEW(TestArgsContainer, tac);
  tac->reg = r->regPtr ;
  tac->bitnum = container_to_uimm_ptr(bitnum);
  return tac;
}

TestArgsContainer *handle_test_form2(RegContainer *r)
{
  NEW(TestArgsContainer, tac);
  if (r->isfield)
    {
      if (get_bitfield_size(r->bitfield) != 1)
	{
	  parseAlo->logException(shared_ptr<IllegalBitopOperand>(new IllegalBitopOperand("bitfield should only be single-bit wide",
											 get_src_line(), 
											 get_src_file(), 
											 __LINE__, __FILE__)));  
	}
      tac->reg = r->regPtr;
      tac->bitnum = llirFactory->createUnsignedImmediate(r->bitfield->getLSBitPosition());
    }
  else
    {
      parseAlo->logException(shared_ptr<IllegalBitopOperand>(new IllegalBitopOperand("argument must be a 1-bit bitfield",
										     get_src_line(), 
										     get_src_file(), 
										     __LINE__, __FILE__)));    
      tac->reg = r->regPtr;
      tac->bitnum = llirFactory->createUnsignedImmediate(0);
    }

  return tac;
}


static unsigned long get_bitfield_size(shared_ptr<const BitField> bf)
{
  return (bf->getMSBitPosition() - bf->getLSBitPosition() + 1);
}

/* Returns the bit position of the first non-zero bit in the argument, starting from LSB. */
static int bit_position(int value)
{
  int position = 0;
  
  while (position < 32)
    {
      if ((value & 1) == 1)
	{
	  break;
	}
      else
	{
	  position++;
	  value >>= 1;
	}
    }

  if (position == 32)
    {
      position = 0;
    }

  return position;
}


static void assert_directive_check(ExpContainer *ec, const char *msg)
{
  if (!msg)
    {
      msg = "assertion failed";
    }
  if (container_to_uimm_ptr(ec)->getValue() == 0)
    {
      /* FIXME: Do we need a new exception class? */
      parseAlo->logException(shared_ptr<ErrorDirectiveException>(new ErrorDirectiveException(msg,
											     get_src_line(), 
											     get_src_file(), 
											     __LINE__, __FILE__)));
    }
}


static void add_label_symbol(const char *label_name, OctaveSymbol::ScopeQualifier q)
{
  shared_ptr<LabelSymbol> sym;
  sym = llirFactory->createLabelSymbol(label_name, q);
  const char* mangled_name = sym->getMangledName().c_str();
  shared_ptr<Label> label;

  AddOctaveSymbol(sym);

  if(q == OctaveSymbol::LOCAL)
    {
      label = llirFactory->createLocalLabelDirective(get_node_line(), 
						     get_src_line(),
						     get_src_file(), label_name, mangled_name);
      g_currentBlock->addLlirNode(g_currentBlock,label);
#ifdef OPTIMIZING_ALO      
      if (in_jtable)
	g_currentJtableBegin->addLabelEntry(label);
#endif
    }
  else if(q == OctaveSymbol::FILESCOPE)
    {
      label = llirFactory->createFileScopeLabelDirective(get_node_line(), 
							 get_src_line(),
							 get_src_file(), label_name, mangled_name);
      g_currentBlock->addLlirNode(g_currentBlock,label);
    }
  else if (q == OctaveSymbol::GLOBAL)
    {
      shared_ptr<GlobalLabel> gl = llirFactory->createGlobalLabelDirective(get_node_line(), 
									   get_src_line(),
									   get_src_file(), label_name, mangled_name); 
      g_currentBlock->addLlirNode(g_currentBlock, gl);	

#ifdef OPTIMIZING_ALO      
      if (in_evh || in_entry)
	g_currentAltEntryFn->addLabelEntry(gl);
#endif

      label = gl;
    }
  else
    {
      /* log... */
      yyerror("Unknown scope qualifier");
    }

#ifdef OPTIMIZING_ALO
  if (optimizing && noopt_active)
    {
      label->setInSequence();
    }
#endif

}

static shared_ptr<const Register> 
combine_single_regs_into_multi_reg(shared_ptr<const Register> r1, shared_ptr<const Register> r2)
{
  if (isMultiReg(r1) || isMultiReg(r2))
    {
      parseAlo->logException(shared_ptr<IllegalRegisterOperand>(new IllegalRegisterOperand("multireg cannot be part of regrange expression",
											   get_src_line(), get_src_file(), 
											   __LINE__, __FILE__)));
      return (llirFactory->createNullReg());
    }
  else 
    {
      if (r2->getRegNum() < r1->getRegNum())
	{
	  parseAlo->logException(shared_ptr<IllegalRegisterOperand>(new IllegalRegisterOperand("Second register of register range must be greater than first register",
											       get_src_line(), get_src_file(), 
											       __LINE__, __FILE__)));
	  return (llirFactory->createNullReg());
	}

      unsigned int numRegs = r2->getRegNum() - r1->getRegNum() + 1;

      /* Verify both are same type (hard or pseudo) */
      if (isPseudoReg(r1) && isPseudoReg(r2))
	{

	  if (r1->getRegName() != r2->getRegName())
	    {
	      parseAlo->logException(shared_ptr<IllegalRegisterOperand>(new IllegalRegisterOperand("Both symbolic registers must have same name for register range",
												   get_src_line(), get_src_file(), 
												   __LINE__, __FILE__)));
	      return (llirFactory->createNullReg());
	    }

	  return (llirFactory->createMultiPseudoReg(numRegs,
						    r1->getRegNum(),
						    r1->getRegName().c_str()));
	}
      else if (!isPseudoReg(r1) && !isPseudoReg(r2))
	{
	  return (llirFactory->createMultiHardReg(numRegs,
						  r1->getRegNum()));
	}
      else
	{
	  parseAlo->logException(shared_ptr<IllegalRegisterOperand>(new IllegalRegisterOperand("Cannot mix register types in register range",
											       get_src_line(), get_src_file(), 
											       __LINE__, __FILE__)));
	  return (llirFactory->createNullReg());
	}
    }
}

static RegContainer *combine_single_regs_into_multi_reg(RegContainer *r1, RegContainer *r2)
{
  NEW(RegContainer, rc);

  rc->regPtr = combine_single_regs_into_multi_reg(r1->regPtr, r2->regPtr);
  return rc;
}


/* 
 * Convert either a single or multi register to a new single register,
 * based on the original register number plus an offset. 
 */
static RegContainer *clone_reg_as_single_with_offset(RegContainer *r, int offset)
{
  NEW(RegContainer, rc);

  /*    Bounds checking                                                */
  /*    if(r->regPtr->getRegNum(0) + offset > r->regPtr->getNumRegs()) */
  /*      {                                                            */
  /*        FIXME : logException, "register out of range"              */
  /*      }                                                            */


  /* FIXME: Can do range checking here - check if "r" is a multireg; if so, does offset spill past the end? */
  if (isPseudoReg(r->regPtr))
    {
      rc->regPtr = llirFactory->createPseudoReg(r->regPtr->getRegNum() + offset, r->regPtr->getRegName().c_str());
    }
  else
    {
      rc->regPtr = llirFactory->createHardReg(r->regPtr->getRegNum() + offset);
    }
  return rc;
}


CondBranchFlagsContainer::CondBranchFlagsContainer()
{ 
  c_bit = 0; 
  bf_bit = 0; 
}

void CondBranchFlagsContainer::finalize()
{
  if (c_bit && bf_bit)
    {
      flags = llirFactory->createCbranchFlags(llirFactory->createCbranchFlag(OctaveFactory::C),
					      llirFactory->createCbranchFlag(OctaveFactory::BF));
    }
  else if (c_bit)
    {
      flags = llirFactory->createCbranchFlags(llirFactory->createCbranchFlag(OctaveFactory::C));
    }
  else if (bf_bit)
    {
      flags = llirFactory->createCbranchFlags(llirFactory->createCbranchFlag(OctaveFactory::BF));
    }
  else 
    {
      flags = llirFactory->createNullOperand();
    }

  if (!ess)
    {
      parseAlo->logException(shared_ptr<MissingRequiredOperand>(new MissingRequiredOperand("ESS flag not specified",
											   get_src_line(), 
											   get_src_file(), 
											   __LINE__, __FILE__)));
    }
  if (!rd)
    {
      rd = llirFactory->createNullOperand();
    }
}


BrslArgsContainer::BrslArgsContainer()
{
  ul = 0;
  dlnk = 0;
  fl = 0;
  pr = 0;
}


void BrslArgsContainer::finalize()
{
  int n = 0;
  shared_ptr<BrslFlag> _flags[4];

  if (ul)
    {
      _flags[n++] = llirFactory->createBrslFlag(OctaveFactory::UNLNK);
    }
  if (dlnk)
    {
      _flags[n++] = llirFactory->createBrslFlag(OctaveFactory::DLNK);
    }
  if (fl)
    {
      _flags[n++] = llirFactory->createBrslFlag(OctaveFactory::FLUSH);
    }
  if (pr)
    {
      _flags[n++] = llirFactory->createBrslFlag(OctaveFactory::PRE);
    }

  switch (n)
    {
    case 0:
      flags = llirFactory->createNullOperand();
      break;
    case 1:
      flags = llirFactory->createBrslFlags(_flags[0]);
      break;
    case 2:
      flags = llirFactory->createBrslFlags(_flags[0], _flags[1]);
      break;
    case 3:
      flags = llirFactory->createBrslFlags(_flags[0], _flags[1], _flags[2]);
      break;
    case 4:
      flags = llirFactory->createBrslFlags(_flags[0], _flags[1], _flags[2], _flags[3]);
      break;
    default:
      assert(0);
    }
}


static ExpContainer *unsigned_immed_container(unsigned int value)
{
  NEW(ConstantContainer, p);
  p->exprPtr = llirFactory->createUnsignedImmediate(value);
  return p;
}


static ExpContainer *label_container(const char *st)
{
  /* First check if symbol is defined and is not a label. */
  shared_ptr<OctaveSymbol> sym = lookupOctaveSymbol(st);
  if (shared_ptr<RegSymbol> regSym = shared_dynamic_cast<RegSymbol>(sym))
    {
      ostringstream excStr;
      excStr << st << " is already defined as a symbolic register\n";
      parseAlo->logException(shared_ptr<IllegalExpression>(new IllegalExpression(excStr.str().c_str(),
										 get_src_line(), 
										 get_src_file(), 
										 __LINE__, __FILE__)));
    }

  /* Create the label (even if there was an error, so parsing can continue). */
  NEW(LabelContainer, p);
  shared_ptr<OpndLabel> label = llirFactory->createLabel(st);
  p->exprPtr = label;
  /* Store label operand to be decorated with mangled name in fixup pass. */
  g_currentBlock->storeLabelOpnd(label);
  return p;
}

static shared_ptr<const UnsignedImmediate> container_to_uimm_ptr(ExpContainer *e)
{
  if (e->exprPtr->isConstantExpr())
    {
      return shared_static_cast<const UnsignedImmediate>(e->exprPtr);
    }
  else
    {
      parseAlo->logException(shared_ptr<IllegalExpression>(new IllegalExpression("non-constant expression",
										 get_src_line(), 
										 get_src_file(), 
										 __LINE__, __FILE__)));
      /* Return dummy object to allow parsing to continue. */
      return llirFactory->createUnsignedImmediate(0);
    }
}

static shared_ptr<const SignedImmediate> container_to_simm_ptr(ExpContainer *e)
{
  if (e->exprPtr->isConstantExpr())
    {
      /* Constants are stored as unsigned immediates throughout the expression grammar
       * for convenience, and the host native 32-bit arithmetic makes things "just work".
       * This is the one point where we convert things to SignedImmediate for LLIR. */
      shared_ptr<const SignedImmediate> si = 
	llirFactory->createSignedImmediate(e->exprPtr->getConstantValue());
      return si;
    }
  else
    {
      parseAlo->logException(shared_ptr<IllegalExpression>(new IllegalExpression("non-constant expression",
										 get_src_line(), 
										 get_src_file(), 
										 __LINE__, __FILE__)));
      /* Return dummy object to allow parsing to continue. */
      return llirFactory->createSignedImmediate(0);
    }
}


static shared_ptr<const LlirOperand> container_check_branch_expr(ExpContainer *e)
{
  /* Following mxtas conventions, a branch expression must contain a relocatable symbol. */
  if (! e->getLabelCount())
    {
      parseAlo->logException(shared_ptr<IllegalExpression>(new IllegalExpression("expression must include a label",
										 get_src_line(), 
										 get_src_file(), 
										 __LINE__, __FILE__)));
    }
  /* Return exprPtr in either case to allow parsing to contine. */
  return e->exprPtr;
}


static ExpContainer *parens_eval(ExpContainer *e)
{
  ExpContainer *tmp;

  if ((tmp = dynamic_cast<LabelContainer*>(e))
      || (tmp = dynamic_cast<ConstantContainer*>(e))
      || (tmp = dynamic_cast<ParensContainer*>(e)))
    {
      /* Ignore enclosing parens. */
      return e;
    }
  else
    {
      NEW(ParensContainer, p);
      p->exprPtr = llirFactory->createParenthesesExpr(e->exprPtr);
      p->updateLabelCount(e);
      return p;
    }
}


int ExpContainer::getLabelCount()
{
  return this->labelCount;
}


void ExpContainer::updateLabelCount(ExpContainer *lhs, ExpContainer *rhs)
{
  this->labelCount = lhs->getLabelCount() + rhs->getLabelCount();
}

void ExpContainer::updateLabelCount(ExpContainer *e)
{
  this->labelCount = e->getLabelCount();
}


static ExpContainer *generic_op_check_label(ExpContainer *ec)
{
  /* If labels involved, it fails. */
  if (ec->getLabelCount())
    {
      parseAlo->logException(shared_ptr<IllegalExpression>(new IllegalExpression("expression cannot include a label",
										 get_src_line(), 
										 get_src_file(), 
										 __LINE__, __FILE__)));
      NEW(ErrorContainer, e);
      /* This has to contain something to allow the expression parsing to continue,
	 so just use an unsigned immediate = 0. */
      e->exprPtr =  llirFactory->createUnsignedImmediate(0);
      return e;
    }
  else
    {
      return NULL;
    }
}


static ExpContainer *generic_op_check_labels(ExpContainer *lhs, ExpContainer *rhs)
{
  /* If labels involved on either side, it fails. */
  ExpContainer *ret;
  if ((ret = generic_op_check_label(lhs)))
    {
      return ret;
    }
  else if ((ret = generic_op_check_label(rhs)))
    {
      return ret;
    }
  else
    {
      return NULL; 
    }
}


static ExpContainer *add_op_check_labels(ExpContainer *lhs, ExpContainer *rhs)
{
  /* If the expression is a constant, let it through, else call generic_op_check_labels(). */
  if ((lhs->getLabelCount() == 1) && (rhs->exprPtr->isConstantExpr()))
    {
      return NULL;
    }
  else if ((lhs->exprPtr->isConstantExpr()) && (rhs->getLabelCount() == 1))
    {
      return NULL;
    }
  else
    {
      return generic_op_check_labels(lhs, rhs);
    }
}


static ExpContainer *subtract_op_check_labels(ExpContainer *lhs, ExpContainer *rhs)
{
  /* If the expressions are constant, let it through, else call generic_op_check_labels(). */

  if ((lhs->getLabelCount() == 1) && (rhs->exprPtr->isConstantExpr()))
    {
      return NULL;
    }
  else if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))
    {
      return NULL;
    }
  else
    {
      return generic_op_check_labels(lhs, rhs);
    }
}


static ExpContainer *add_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = add_op_check_labels(lhs, rhs))) { return err; }

  if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))
    {
      NEW(ConstantContainer, e);
      unsigned long value;

      value = lhs->exprPtr->getConstantValue() + rhs->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      NEW(PlusContainer, e);
      e->exprPtr = llirFactory->createPlusExpr(lhs->exprPtr, rhs->exprPtr);
      e->updateLabelCount(lhs, rhs);
      return e;
    }
} 


static ExpContainer *subtract_op(ExpContainer *lhs, ExpContainer *rhs)
{
  LabelContainer *lableft, *labright;

  if ((lableft = dynamic_cast<LabelContainer *>(lhs)) && (labright = dynamic_cast<LabelContainer *>(rhs)))
    {
      NEW(MinusContainer, e);
      e->exprPtr = llirFactory->createMinusExpr(lhs->exprPtr, rhs->exprPtr);
      /* Do not update labelCount, these labels will be subtracted in
	 the back end so they don't count. */
      return e;
    }

  ExpContainer *err = NULL; if ((err = subtract_op_check_labels(lhs, rhs))) { return err; }
  
  if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))
    {
      NEW(ConstantContainer, e);
      unsigned long value;
      value = lhs->exprPtr->getConstantValue() - rhs->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      NEW(MinusContainer, e);
      e->exprPtr = llirFactory->createMinusExpr(lhs->exprPtr, rhs->exprPtr);
      e->updateLabelCount(lhs, rhs);
      return e;
    }
} 


static ExpContainer *multiply_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))
    {
      NEW(ConstantContainer, e);
      unsigned long value;

      value = lhs->exprPtr->getConstantValue() * rhs->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      NEW(MultiplyContainer, e);
      e->exprPtr = llirFactory->createMultiplyExpr(lhs->exprPtr, rhs->exprPtr);
      return e;
    }
} 


static ExpContainer *divide_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }

  if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))  
    {
      NEW(ConstantContainer, e);
      unsigned long value;
      value = lhs->exprPtr->getConstantValue() / rhs->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      NEW(DivContainer, e);
      e->exprPtr = llirFactory->createDivExpr(lhs->exprPtr, rhs->exprPtr);
      e->updateLabelCount(lhs, rhs);
      return e;
    }
} 


static ExpContainer *modulo_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))
    {
      NEW(ConstantContainer, e);
      unsigned long value;
      value = lhs->exprPtr->getConstantValue() % rhs->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      NEW(ModulusContainer, e);
      e->exprPtr = llirFactory->createModulusExpr(lhs->exprPtr, rhs->exprPtr);
      e->updateLabelCount(lhs, rhs);
      return e;
    }
} 


static ExpContainer *or_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))
    {
      NEW(ConstantContainer, e);
      unsigned long value;

      value = lhs->exprPtr->getConstantValue() | rhs->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      NEW(BitWiseOrContainer, e);
      e->exprPtr = llirFactory->createBitWiseOrExpr(lhs->exprPtr, rhs->exprPtr);
      e->updateLabelCount(lhs, rhs);
      return e;
    }
} 


static ExpContainer *and_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))
    {
      NEW(ConstantContainer, e);
      unsigned long value;

      value = lhs->exprPtr->getConstantValue() & rhs->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      NEW(BitWiseAndContainer, e);
      e->exprPtr = llirFactory->createBitWiseAndExpr(lhs->exprPtr, rhs->exprPtr);
      e->updateLabelCount(lhs, rhs);
      return e;
    }
} 


static ExpContainer *xor_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))
    {
      NEW(ConstantContainer, e);
      unsigned long value;

      value = lhs->exprPtr->getConstantValue() ^ rhs->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      NEW(BitWiseXorContainer, e);
      e->exprPtr = llirFactory->createBitWiseXorExpr(lhs->exprPtr, rhs->exprPtr);
      e->updateLabelCount(lhs, rhs);
      return e;
    }
} 


static ExpContainer *leftshift_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }

  if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))  
    {
      NEW(ConstantContainer, e);
      unsigned long value;

      value = lhs->exprPtr->getConstantValue() << rhs->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      NEW(LeftShiftContainer, e);
      e->exprPtr = llirFactory->createLeftShiftExpr(lhs->exprPtr, rhs->exprPtr);
      e->updateLabelCount(lhs, rhs);
      return e;
    }
} 


static ExpContainer *rightshift_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  if ((lhs->exprPtr->isConstantExpr()) && (rhs->exprPtr->isConstantExpr()))  
    {
      NEW(ConstantContainer, e);
      unsigned long value;

      value = lhs->exprPtr->getConstantValue() >> rhs->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      NEW(RightShiftContainer, e);
      e->exprPtr = llirFactory->createRightShiftExpr(lhs->exprPtr, rhs->exprPtr);
      e->updateLabelCount(lhs, rhs);
      return e;
    }
} 


static ExpContainer *negate_op(ExpContainer *ec)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_label(ec))) { return err; }

  if (ec->exprPtr->isConstantExpr())
    {
      NEW(ConstantContainer, e);
      unsigned long value;

      value = -ec->exprPtr->getConstantValue();
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      /* Have to handle for example "-(bar - foo)". */
      NEW(UnaryMinusContainer, e);
      e->exprPtr = llirFactory->createUnaryMinusExpr(ec->exprPtr);
      return e;
    }
} 


static ExpContainer *ones_complement_op(ExpContainer *ec)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_label(ec))) { return err; }

  if (ec->exprPtr->isConstantExpr())
    {
      NEW(ConstantContainer, e);
      unsigned long value;

      value = ~(ec->exprPtr->getConstantValue());
      e->exprPtr = llirFactory->createUnsignedImmediate(value);
      return e;
    }
  else
    {
      /* We don't support non-constant expressions for ones-complement. */
      parseAlo->logException(shared_ptr<IllegalExpression>(new IllegalExpression("one's complement operator can only be used for constant expressions",
										 get_src_line(), 
										 get_src_file(), 
										 __LINE__, __FILE__)));
      NEW(ErrorContainer, e);
      /* This has to contain something to allow the expression parsing to continue,
	 so just use an unsigned immediate = 0. */
      e->exprPtr =  llirFactory->createUnsignedImmediate(0);
      return e;
    }
} 


static ExpContainer *assert_op(ExpContainer *tested_ex, ExpContainer *returned_ex)
{
  if (container_to_uimm_ptr(tested_ex)->getValue() == 0)
    {
      parseAlo->logException(shared_ptr<ErrorDirectiveException>(new ErrorDirectiveException("assertion failed",
											     get_src_line(), 
											     get_src_file(), 
											     __LINE__, __FILE__)));      
    }
  return returned_ex;
}



static ExpContainer *andand_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  NEW(ConstantContainer, e);
  unsigned long value;
  
  value = lhs->exprPtr->getConstantValue() && rhs->exprPtr->getConstantValue();
  e->exprPtr = llirFactory->createUnsignedImmediate(value);
  return e;    
}


static ExpContainer *oror_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  NEW(ConstantContainer, e);
  unsigned long value;
  
  value = lhs->exprPtr->getConstantValue() || rhs->exprPtr->getConstantValue();
  e->exprPtr = llirFactory->createUnsignedImmediate(value);
  return e;    
}


static ExpContainer *geq_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  NEW(ConstantContainer, e);
  unsigned long value;
  
  value = lhs->exprPtr->getConstantValue() >= rhs->exprPtr->getConstantValue();
  e->exprPtr = llirFactory->createUnsignedImmediate(value);
  return e;    
}



static ExpContainer *leq_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  NEW(ConstantContainer, e);
  unsigned long value;
  
  value = lhs->exprPtr->getConstantValue() <= rhs->exprPtr->getConstantValue();
  e->exprPtr = llirFactory->createUnsignedImmediate(value);
  return e;    
}



static ExpContainer *gt_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  NEW(ConstantContainer, e);
  unsigned long value;
  
  value = lhs->exprPtr->getConstantValue() > rhs->exprPtr->getConstantValue();
  e->exprPtr = llirFactory->createUnsignedImmediate(value);
  return e;    
}


static ExpContainer *lt_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  NEW(ConstantContainer, e);
  unsigned long value;
  
  value = lhs->exprPtr->getConstantValue() < rhs->exprPtr->getConstantValue();
  e->exprPtr = llirFactory->createUnsignedImmediate(value);
  return e;    
}


static ExpContainer *eq_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  NEW(ConstantContainer, e);
  unsigned long value;
  
  value = lhs->exprPtr->getConstantValue() == rhs->exprPtr->getConstantValue();
  e->exprPtr = llirFactory->createUnsignedImmediate(value);
  return e;    
}



static ExpContainer *neq_op(ExpContainer *lhs, ExpContainer *rhs)
{
  ExpContainer *err = NULL; if ((err = generic_op_check_labels(lhs, rhs))) { return err; }
  
  NEW(ConstantContainer, e);
  unsigned long value;
  
  value = lhs->exprPtr->getConstantValue() != rhs->exprPtr->getConstantValue();
  e->exprPtr = llirFactory->createUnsignedImmediate(value);
  return e;    
}
