#include <iostream>
#include <fstream>
#include <cstdio>
#include <unistd.h>

#include <sys/types.h>
typedef long blksize_t; // JOE we need to fix this....

#include <sys/stat.h>

#include <Alo.h>
#include <LlirFile.h>
#include <LlirException.h>
using namespace Llir;

#include <AloException.h>
#include <OctaveDelaySlotAnalyzer.h>
#include <OctaveSequenceAnalyzer.h>
#include <M480Factory.h>
#include <M480PrintVisitor.h>

#include "M480BranchInsnVisitor.h"
#include "M480Alo.h"

#ifdef GCCBUILD
#include "M480GenRtlVisitor.h"
#include "M480UpdateOpndVisitor.h"
#include <BasicBlock.h>
#include <M480CfgBuilder.h>
#include <M480DFAnalyzer.h>
#include <CfgDumper.h>

extern int optimize;		// FIXME: boolean function call.
extern "C" {
#include "llir-gcc-connection.h"
  //this gets initialized in toplev.c 
  extern FILE *asm_out_file;
}

#else
int optimize =0;
#endif

#include "M480SemanticVisitor.h"

#include "cmdline.h"


using namespace Alo;
using namespace std;

extern void parse_main(const char *ifile, OctaveAlo &alo, shared_ptr<LlirFile>);

namespace Alo
{
  extern string fileBaseName(const string &fileName);
  extern const std::string getBaseName(const std::string& fileName);

  // M480Alo

  M480Alo::M480Alo() : 
    OctaveAlo(),
    m_asm(),
    m_M480Factory(new M480Factory),
    m_preprocessedFileName(""),
    m_aloGeneratedAsmFileName(""),
    m_cfgDumpFileName("")
  {}

  M480Alo::~M480Alo()
  {}

  M480Alo::M480Alo(const M480Alo& rhs)
    : OctaveAlo(rhs),
    m_asm(rhs.m_asm),
    m_M480Factory(rhs.m_M480Factory),
    m_preprocessedFileName(rhs.m_preprocessedFileName),
    m_aloGeneratedAsmFileName(rhs.m_aloGeneratedAsmFileName),
    m_cfgDumpFileName(rhs.m_cfgDumpFileName)
  {}

  M480Alo& 
  M480Alo::operator=(const M480Alo& rhs)
  {
    if(this == &rhs)
      return *this;

    OctaveAlo::operator=(rhs);
    m_asm = rhs.m_asm;
    m_M480Factory = rhs.m_M480Factory;
    m_preprocessedFileName = rhs.m_preprocessedFileName;
    m_aloGeneratedAsmFileName = rhs.m_aloGeneratedAsmFileName;
    m_cfgDumpFileName = rhs.m_cfgDumpFileName;
    return *this;
  }

  void
  M480Alo::assemble(int argc, char *argv[])
  {
    parseCommandLine(argc, argv);

    const char *fileName;

    for (OctaveAlo::Iterator it = begin(); it != end(); it++)
      {

	fileName = (*it)->getName().c_str();
		
	// The ".i2" is generated by the print visitor.
	m_aloGeneratedAsmFileName = fileBaseName(getBaseName(fileName)) + ".i2";
		
	preprocessAsmFile(fileName);
		
	//parse input .s/.alo file and 
	//generate rtl once per fn/evh.
		
	parseAsmFile(*it);
		
	// FIXME:  Can hoist up most of the common code in the if/else blocks here.
	if (!optimize)
	  {
	    if (!aloCmdLine.m_explicitObjectFileSpecified)
	      {
		setObjectFileName((fileBaseName(getBaseName((*it)->getName())) + ".o").c_str());
	      }
			
	    // iterate over all nodes of the file
	    // and analyze their semantics.

	    LlirFile::Iterator nIter = (*it)->begin();
	    for(; nIter != (*it)->end(); nIter++)
	      {
		analyzeSemantics(*nIter);
	      }
			
	    if(! aloCmdLine.m_noDslotWarn)
	      {
		checkDelaySlots(*it);
	      }
			
	    handleLoggedExceptions();
			
	    if(getNumErrors() == 0)
	      {
		printAssemblyFile(*it);
		generateObjectCode(fileName);
	      }
	  }
	else
	  {
	    // The ".s2" is generated by cc1alo.
	    m_aloGeneratedAsmFileName = fileBaseName(getBaseName((*it)->getName())) + ".s2";


	    // The ".cfg" file generated
	    m_cfgDumpFileName = fileBaseName(getBaseName((*it)->getName())) + ".cfg";


#ifdef GCCBUILD
	    // asm_out_file holds the handle for the opened .s2 file.
	    // The output file needs to be flushed before
	    // calling back-end assembler.
	    fflush(asm_out_file);
#endif

	    if (!aloCmdLine.m_explicitObjectFileSpecified)
	      {
		setObjectFileName((fileBaseName(getBaseName((*it)->getName())) + ".o").c_str());
	      }

	    handleLoggedExceptions();

	    if(getNumErrors() == 0)
	      {
		generateObjectCode(fileName);
	      }
	  }

	if (!aloCmdLine.m_saveTemps)
	  {
	    unlink(m_preprocessedFileName.c_str());
	    unlink(m_aloGeneratedAsmFileName.c_str());
	  }
      }
  }


  void
  M480Alo::checkDelaySlots(shared_ptr<LlirFile> file)
  {
    //*this is passed along so that the analyzer
    //can log exceptions.
    OctaveDelaySlotAnalyzer dslotAnalyzer(*this);

    dslotAnalyzer.checkDelaySlots(file);
  }


  //   void
  //   M480Alo::analyzeSemantics(shared_ptr<LlirFile> file)
  //   {
  //     LlirFile::Iterator it = file->begin();
  //     M480SemanticAnalysisVisitor semanticVisitor(*this);
  //     for (; it != file->end(); it++)
  //       (*it)->accept(semanticVisitor);
  //   }

  void
  M480Alo::analyzeSemantics(shared_ptr<LlirNode> node)
  {
    M480SemanticAnalysisVisitor semanticVisitor(*this);
    node->accept(semanticVisitor);
  }

  void
  M480Alo::markSequenceInsns(shared_ptr<LlirOctaveBlock> blk)
  {
#if GCCBUILD
    OctaveSequenceAnalyzer seqAnalyzer(*this);

    seqAnalyzer.makeSequences(blk);
#endif
  }


  void 
  M480Alo::parseAsmFile(shared_ptr<LlirFile> llirFile)
  {
    parse_main(m_preprocessedFileName.c_str(), *this, llirFile);
  }

  void 
  M480Alo::preprocessAsmFile(const char *asmFileName)
  {
    m_preprocessedFileName = m_asm.preprocessFile(asmFileName, aloCmdLine.m_cppPath, aloCmdLine.m_cppOptions);
  }


  void
  M480Alo::generateObjectCode(const char* asmFileName)
  {

    string asmOptions = " --nocpp "; //to disable mxtas as_cpp
    
    if(getNumWarnings())
      {
	//disable warnings in the back end assembler if 
	//alo already generated them...
	
	asmOptions += " -W ";
      }
 
    m_asm.assembleFile(m_aloGeneratedAsmFileName,
		       getObjectFileName(),
		       asmOptions);
  }


  void
  M480Alo::printAssemblyFile(shared_ptr<LlirFile> file)
  {
    ofstream outAsmFile(m_aloGeneratedAsmFileName.c_str());

    if (!outAsmFile)
      throw AloInternalException("Unable to open assembly language file for output", __LINE__, __FILE__);

    M480PrintVisitor printVisitor(outAsmFile);
    LlirFile::Iterator it = file->begin();

    for (; it != file->end(); it++)
      (*it)->accept(printVisitor);
  }


  void
  M480Alo::parseCommandLine(int argc, char *argv[])
  {
    int optind;

    optind = cmdline_process_all_options(argc, argv);

    if (aloCmdLine.m_errorLimit_set)
      {
	if (aloCmdLine.m_errorLimit > 0)
	  setMaxErrors(aloCmdLine.m_errorLimit);
	else
	  printWarning("Error limit must be > 0. Option ignored.");
      }

    // Note: there is NO else case here.  If the object file name was
    // not explicitly specified, we should handle the case where there
    // are multiple input files, and derive the object file name
    // with each iteration.  We handle that in the ::assemble metod.
    if (aloCmdLine.m_explicitObjectFileSpecified)
      {
	setObjectFileName(aloCmdLine.m_objectFileName);
      }

    if (optind == argc)
      throw NoInputFileSpecified("No input file specified", __LINE__, __FILE__);

    struct stat buf;
    for (int i = optind, numFiles = 0; i < argc; i++, numFiles++)
      {
	if (stat(argv[i], &buf) == 0)
	  {
	    if (aloCmdLine.m_explicitObjectFileSpecified == true && numFiles == 1)
	      {
		printFatalError("Cannot specifiy -o <objfile> and more than one assembly file");
	      }
	    createLlirFile(argv[i]);
	  }
	else
	  {
	    string s = "File \"" + string(argv[i]) + "\" could not be found.";
	    throw AloInternalException(s.c_str(), __LINE__, __FILE__);
	  }
      }
  }


  shared_ptr<Llir::OctaveFactory>
  M480Alo::getFactory() const
  {
    return m_M480Factory;
  }

  void
  M480Alo::displayUsage()
  {
    cerr << endl;
    cerr << "Usage: " << "alo" << " [options] file\n";
    cerr << endl;
    cerr << "Options:\n";
    cerr << "-h, --help        Display this help and exit\n";
    cerr << "-v                Does nothing\n";
    cerr << "--version         Does nothing\n";
    cerr << "--verbose         Does nothing\n";
    cerr << "--cpp_path=PATH   Specify the path to the preprocessor to \n";
    cerr << "                  run on the source file. The default is \n";
    cerr << "                  found in MAKER_ROOT.\n";
    cerr << "--Wno-dslot-warn  Do not show invalid delay slot warnings \n";
    cerr << "-I FILE           Include FILE.\n";
    cerr << "-D <var>          Define  var\n";
    cerr << "--dump-cfg        Dump Control Flow Graph of the function \n";
    cerr << "--yydebug         Turn on parser debug output to stderr\n";
    cerr << endl;
  }


  

  void
  M480Alo::analyzeCurrentFunction(shared_ptr<LlirNode> node)
  {
#ifdef GCCBUILD

    shared_ptr<AltEntryFunction> fn = shared_dynamic_cast<AltEntryFunction>(node);

    if(fn)
      {
	string name = fn->getEntryPtList()->getLabel(0)->getName();

	bool foundReturnInsn = checkForReturnInsn(fn->getImplicitBlock());

	if(!foundReturnInsn)
	  {
	    shared_ptr<std::exception> exc; 
	    string err = "Return Stmt missing in the Function/Evh : " + name;
	    exc = shared_ptr<RtlGenerationException>(new RtlGenerationException(err.c_str(), 0, name.c_str(), __LINE__, __FILE__));
	    logException(exc);
	  }
      }

#endif
  }


  bool
  M480Alo::checkForReturnInsn(shared_ptr<LlirOctaveBlock> blk)
  {
    bool returnInsnFound = false;

    LlirNode::Iterator iter = blk->begin();
    for(; iter != blk->end(); iter++)
      {
	shared_ptr<LlirNode> node = *iter;

	shared_ptr<OctaveInstruction> insn = shared_dynamic_cast<OctaveInstruction>(node);
	shared_ptr<LlirOctaveBlock> child = shared_dynamic_cast<LlirOctaveBlock>(node);
	
	if(insn && insn->isReturnInsn())
	  {
	    returnInsnFound = true;
	  }
	else if(child)
	  {
	    returnInsnFound = checkForReturnInsn(child);
	  }

	if(returnInsnFound)
	  break;
      }

    return returnInsnFound;
  }

  void
  M480Alo::generateRTL(shared_ptr<LlirNode> node)
  {
#ifdef GCCBUILD

    M480GenRtlVisitor rtlVisitor(*this);

    node->accept(rtlVisitor);

#endif
  }

  void
  M480Alo::identifyBranchTargets(shared_ptr<AltEntryFunction> node)
  {
#ifdef GCCBUILD

    M480BranchInsnVisitor branchInsnVisitor(*this, node);
    
    node->accept(branchInsnVisitor);

#endif
  }


  void
  M480Alo::identifyCallTargets(shared_ptr<AltEntryFunction> node)
  {
#ifdef GCCBUILD
    
    M480CallInsnVisitor callInsnVisitor(*this, node);
    
    node->accept(callInsnVisitor);


#endif
  }

  void
  M480Alo::identifyLiveEssRegisters(shared_ptr<AltEntryFunction> f)
  {
#ifdef GCCBUILD

    //populate the set of used and set operands on insns
    M480UpdateOpndVisitor mpv(*this, f);

    f->accept(mpv);



    //build flow graph  
    shared_ptr<ControlFlowGraph<BasicBlock<LlirNode, BitVector>, Edge> > cfg;

    M480CFGBuilder cfgBuilder(f);
  
    cfgBuilder.buildFlowGraph();
  
    cfg = cfgBuilder.getControlFlowGraph();

    //perform liveness analysis
    M480DataFlowAnalyzer dfaAnalyzer(f, cfg);

    dfaAnalyzer.updateBasicBlockLiveNess();

    if(aloCmdLine.m_dumpCfg)
      {
	//dump cfg and dfa info
	printControlAndDataFlowInfo(cfg);
      }

#endif
  }

  void 
  M480Alo::printControlAndDataFlowInfo(shared_ptr<ControlFlowGraph<BasicBlock<LlirNode, BitVector>, Edge> > cfg)
  {
#ifdef GCCBUILD

    const char* name = cfg->getName().c_str();
    
    static char fileBuf[128];

    sprintf(fileBuf, "%s.%s", name, "cfg");

    ofstream cfgDumpStream(fileBuf);

    if(!cfgDumpStream)
      throw AloInternalException("Unable to open cfg dump file", __LINE__, __FILE__);
	    
    shared_ptr<M480CfgDfInfoDumper> cfgDumper(new M480CfgDfInfoDumper(cfgDumpStream, cfg));

    cfgDumper->printControlAndDataFlowInfo();
#endif
  }

}





